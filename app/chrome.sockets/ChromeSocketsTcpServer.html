        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>ChromeSocketsTcpServer class / chrome.sockets Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="chrome.sockets" data-type="ChromeSocketsTcpServer">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../chrome.sockets.html">chrome.sockets</a> &rsaquo; <a href="../chrome.sockets/ChromeSocketsTcpServer.html">ChromeSocketsTcpServer</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>ChromeSocketsTcpServer</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>Use the <code>chrome.sockets.tcpServer</code> API to create server applications using
TCP connections. This API supersedes the TCP functionality previously found
in the <code>chrome.socket</code> API. Note that the socket ids created from this
namespace are not compatible with ids created in other namespaces.</p>
<pre class="source">
class ChromeSocketsTcpServer extends ChromeApi {
 static final JsObject _sockets_tcpServer = chrome['sockets']['tcpServer'];

 ChromeSocketsTcpServer._();

 bool get available =&gt; _sockets_tcpServer != null;

 /**
  * Creates a TCP server socket.
  * [properties]: The socket properties (optional).
  * [callback]: Called when the socket has been created.
  * 
  * Returns:
  * Callback from the `create` method.
  * [createInfo]: The result of the socket creation.
  */
 Future&lt;CreateInfo&gt; create([SocketProperties properties]) {
   if (_sockets_tcpServer == null) _throwNotAvailable();

   var completer = new ChromeCompleter&lt;CreateInfo&gt;.oneArg(_createCreateInfo);
   _sockets_tcpServer.callMethod('create', [jsify(properties), completer.callback]);
   return completer.future;
 }

 /**
  * Updates the socket properties.
  * [socketId]: The socket identifier.
  * [properties]: The properties to update.
  * [callback]: Called when the properties are updated.
  */
 Future update(int socketId, SocketProperties properties) {
   if (_sockets_tcpServer == null) _throwNotAvailable();

   var completer = new ChromeCompleter.noArgs();
   _sockets_tcpServer.callMethod('update', [socketId, jsify(properties), completer.callback]);
   return completer.future;
 }

 /**
  * Enables or disables a listening socket from accepting new connections. When
  * paused, a listening socket accepts new connections until its backlog (see
  * `listen` function) is full then refuses additional connection requests.
  * `onAccept` events are raised only when the socket is un-paused.
  */
 Future setPaused(int socketId, bool paused) {
   if (_sockets_tcpServer == null) _throwNotAvailable();

   var completer = new ChromeCompleter.noArgs();
   _sockets_tcpServer.callMethod('setPaused', [socketId, paused, completer.callback]);
   return completer.future;
 }

 /**
  * Listens for connections on the specified port and address. If the
  * port/address is in use, the callback indicates a failure.
  * [socketId]: The socket identifier.
  * [address]: The address of the local machine.
  * [port]: The port of the local machine.
  * [backlog]: Length of the socket's listen queue. The default value depends
  * on the Operating System (SOMAXCONN), which ensures a reasonable queue
  * length for most applications.
  * [callback]: Called when listen operation completes.
  * 
  * Returns:
  * Callback from the `listen` method.
  * [result]: The result code returned from the underlying network call. A
  * negative value indicates an error.
  */
 Future&lt;int&gt; listen(int socketId, String address, int port, [int backlog]) {
   if (_sockets_tcpServer == null) _throwNotAvailable();

   var completer = new ChromeCompleter&lt;int&gt;.oneArg();
   _sockets_tcpServer.callMethod('listen', [socketId, address, port, backlog, completer.callback]);
   return completer.future;
 }

 /**
  * Disconnects the listening socket, i.e. stops accepting new connections and
  * releases the address/port the socket is bound to. The socket identifier
  * remains valid, e.g. it can be used with `listen` to accept connections on a
  * new port and address.
  * [socketId]: The socket identifier.
  * [callback]: Called when the disconnect attempt is complete.
  */
 Future disconnect(int socketId) {
   if (_sockets_tcpServer == null) _throwNotAvailable();

   var completer = new ChromeCompleter.noArgs();
   _sockets_tcpServer.callMethod('disconnect', [socketId, completer.callback]);
   return completer.future;
 }

 /**
  * Disconnects and destroys the socket. Each socket created should be closed
  * after use. The socket id is no longer valid as soon at the function is
  * called. However, the socket is guaranteed to be closed only when the
  * callback is invoked.
  * [socketId]: The socket identifier.
  * [callback]: Called when the `close` operation completes.
  */
 Future close(int socketId) {
   if (_sockets_tcpServer == null) _throwNotAvailable();

   var completer = new ChromeCompleter.noArgs();
   _sockets_tcpServer.callMethod('close', [socketId, completer.callback]);
   return completer.future;
 }

 /**
  * Retrieves the state of the given socket.
  * [socketId]: The socket identifier.
  * [callback]: Called when the socket state is available.
  * 
  * Returns:
  * Callback from the `getInfo` method.
  * [socketInfo]: Object containing the socket information.
  */
 Future&lt;SocketInfo&gt; getInfo(int socketId) {
   if (_sockets_tcpServer == null) _throwNotAvailable();

   var completer = new ChromeCompleter&lt;SocketInfo&gt;.oneArg(_createSocketInfo);
   _sockets_tcpServer.callMethod('getInfo', [socketId, completer.callback]);
   return completer.future;
 }

 /**
  * Retrieves the list of currently opened sockets owned by the application.
  * [callback]: Called when the list of sockets is available.
  * 
  * Returns:
  * Callback from the `getSockets` method.
  * [socketInfos]: Array of object containing socket information.
  */
 Future&lt;List&lt;SocketInfo&gt;&gt; getSockets() {
   if (_sockets_tcpServer == null) _throwNotAvailable();

   var completer = new ChromeCompleter&lt;List&lt;SocketInfo&gt;&gt;.oneArg((e) =&gt; listify(e, _createSocketInfo));
   _sockets_tcpServer.callMethod('getSockets', [completer.callback]);
   return completer.future;
 }

 Stream&lt;AcceptInfo&gt; get onAccept =&gt; _onAccept.stream;

 final ChromeStreamController&lt;AcceptInfo&gt; _onAccept =
     new ChromeStreamController&lt;AcceptInfo&gt;.oneArg(_sockets_tcpServer, 'onAccept', _createAcceptInfo);

 Stream&lt;AcceptErrorInfo&gt; get onAcceptError =&gt; _onAcceptError.stream;

 final ChromeStreamController&lt;AcceptErrorInfo&gt; _onAcceptError =
     new ChromeStreamController&lt;AcceptErrorInfo&gt;.oneArg(_sockets_tcpServer, 'onAcceptError', _createAcceptErrorInfo);

 void _throwNotAvailable() {
   throw new UnsupportedError("'chrome.sockets.tcpServer' is not available");
 }
}
</pre>
</div>
<h3>Extends</h3>
<p>
<span class="type-box"><span class="icon-class"></span><a href="../chrome.src.common_exp/ChromeApi.html">ChromeApi</a></span>&nbsp;&gt;&nbsp;<span class="type-box"><span class="icon-class"></span><strong>ChromeSocketsTcpServer</strong></span></p>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="available">
<button class="show-code">Code</button>
final bool         <strong>available</strong> <a class="anchor-link"
            href="#available"
            title="Permalink to ChromeSocketsTcpServer.available">#</a>
        </h4>
        <div class="doc">
<div class="inherited">
<p>Returns true if the API is available. The common causes of an API not being
avilable are:</p><ul><li>a permission is missing in the application's manifest.json file</li><li>the API is defined on a newer version of Chrome then the current runtime</li></ul>
<div class="docs-inherited-from">docs inherited from <a href="../chrome.src.common_exp/ChromeApi.html">ChromeApi</a> </div></div>
<pre class="source">
bool get available =&gt; _sockets_tcpServer != null;
</pre>
</div>
</div>
<div class="field"><h4 id="onAccept">
<button class="show-code">Code</button>
final Stream&lt;<a href="../chrome.sockets/AcceptInfo.html">AcceptInfo</a>&gt;         <strong>onAccept</strong> <a class="anchor-link"
            href="#onAccept"
            title="Permalink to ChromeSocketsTcpServer.onAccept">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Stream&lt;AcceptInfo&gt; get onAccept =&gt; _onAccept.stream;
</pre>
</div>
</div>
<div class="field"><h4 id="onAcceptError">
<button class="show-code">Code</button>
final Stream&lt;<a href="../chrome.sockets/AcceptErrorInfo.html">AcceptErrorInfo</a>&gt;         <strong>onAcceptError</strong> <a class="anchor-link"
            href="#onAcceptError"
            title="Permalink to ChromeSocketsTcpServer.onAcceptError">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Stream&lt;AcceptErrorInfo&gt; get onAcceptError =&gt; _onAcceptError.stream;
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="close">
<button class="show-code">Code</button>
Future <strong>close</strong>(int socketId) <a class="anchor-link" href="#close"
              title="Permalink to ChromeSocketsTcpServer.close">#</a></h4>
<div class="doc">
<p>Disconnects and destroys the socket. Each socket created should be closed
after use. The socket id is no longer valid as soon at the function is
called. However, the socket is guaranteed to be closed only when the
callback is invoked.

<span class="param">socketId</span>: The socket identifier.
<code>callback</code>: Called when the <code>close</code> operation completes.</p>
<pre class="source">
Future close(int socketId) {
 if (_sockets_tcpServer == null) _throwNotAvailable();

 var completer = new ChromeCompleter.noArgs();
 _sockets_tcpServer.callMethod('close', [socketId, completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="create">
<button class="show-code">Code</button>
Future&lt;<a href="../chrome.sockets/CreateInfo.html">CreateInfo</a>&gt; <strong>create</strong>([<a href="../chrome.sockets/SocketProperties.html">SocketProperties</a> properties]) <a class="anchor-link" href="#create"
              title="Permalink to ChromeSocketsTcpServer.create">#</a></h4>
<div class="doc">
<p>Creates a TCP server socket.

<span class="param">properties</span>: The socket properties (optional).
<code>callback</code>: Called when the socket has been created.</p>
<p>Returns:
Callback from the <code>create</code> method.
<code>createInfo</code>: The result of the socket creation.</p>
<pre class="source">
Future&lt;CreateInfo&gt; create([SocketProperties properties]) {
 if (_sockets_tcpServer == null) _throwNotAvailable();

 var completer = new ChromeCompleter&lt;CreateInfo&gt;.oneArg(_createCreateInfo);
 _sockets_tcpServer.callMethod('create', [jsify(properties), completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="disconnect">
<button class="show-code">Code</button>
Future <strong>disconnect</strong>(int socketId) <a class="anchor-link" href="#disconnect"
              title="Permalink to ChromeSocketsTcpServer.disconnect">#</a></h4>
<div class="doc">
<p>Disconnects the listening socket, i.e. stops accepting new connections and
releases the address/port the socket is bound to. The socket identifier
remains valid, e.g. it can be used with <code>listen</code> to accept connections on a
new port and address.

<span class="param">socketId</span>: The socket identifier.
<code>callback</code>: Called when the disconnect attempt is complete.</p>
<pre class="source">
Future disconnect(int socketId) {
 if (_sockets_tcpServer == null) _throwNotAvailable();

 var completer = new ChromeCompleter.noArgs();
 _sockets_tcpServer.callMethod('disconnect', [socketId, completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getInfo">
<button class="show-code">Code</button>
Future&lt;<a href="../chrome.sockets/SocketInfo.html">SocketInfo</a>&gt; <strong>getInfo</strong>(int socketId) <a class="anchor-link" href="#getInfo"
              title="Permalink to ChromeSocketsTcpServer.getInfo">#</a></h4>
<div class="doc">
<p>Retrieves the state of the given socket.

<span class="param">socketId</span>: The socket identifier.
<code>callback</code>: Called when the socket state is available.</p>
<p>Returns:
Callback from the <code>getInfo</code> method.
<code>socketInfo</code>: Object containing the socket information.</p>
<pre class="source">
Future&lt;SocketInfo&gt; getInfo(int socketId) {
 if (_sockets_tcpServer == null) _throwNotAvailable();

 var completer = new ChromeCompleter&lt;SocketInfo&gt;.oneArg(_createSocketInfo);
 _sockets_tcpServer.callMethod('getInfo', [socketId, completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getSockets">
<button class="show-code">Code</button>
Future&lt;List&lt;<a href="../chrome.sockets/SocketInfo.html">SocketInfo</a>&gt;&gt; <strong>getSockets</strong>() <a class="anchor-link" href="#getSockets"
              title="Permalink to ChromeSocketsTcpServer.getSockets">#</a></h4>
<div class="doc">
<p>Retrieves the list of currently opened sockets owned by the application.
<code>callback</code>: Called when the list of sockets is available.</p>
<p>Returns:
Callback from the <code>getSockets</code> method.
<code>socketInfos</code>: Array of object containing socket information.</p>
<pre class="source">
Future&lt;List&lt;SocketInfo&gt;&gt; getSockets() {
 if (_sockets_tcpServer == null) _throwNotAvailable();

 var completer = new ChromeCompleter&lt;List&lt;SocketInfo&gt;&gt;.oneArg((e) =&gt; listify(e, _createSocketInfo));
 _sockets_tcpServer.callMethod('getSockets', [completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="listen">
<button class="show-code">Code</button>
Future&lt;int&gt; <strong>listen</strong>(int socketId, String address, int port, [int backlog]) <a class="anchor-link" href="#listen"
              title="Permalink to ChromeSocketsTcpServer.listen">#</a></h4>
<div class="doc">
<p>Listens for connections on the specified port and address. If the
port/address is in use, the callback indicates a failure.

<span class="param">socketId</span>: The socket identifier.

<span class="param">address</span>: The address of the local machine.

<span class="param">port</span>: The port of the local machine.

<span class="param">backlog</span>: Length of the socket's listen queue. The default value depends
on the Operating System (SOMAXCONN), which ensures a reasonable queue
length for most applications.
<code>callback</code>: Called when listen operation completes.</p>
<p>Returns:
Callback from the <code>listen</code> method.
<code>result</code>: The result code returned from the underlying network call. A
negative value indicates an error.</p>
<pre class="source">
Future&lt;int&gt; listen(int socketId, String address, int port, [int backlog]) {
 if (_sockets_tcpServer == null) _throwNotAvailable();

 var completer = new ChromeCompleter&lt;int&gt;.oneArg();
 _sockets_tcpServer.callMethod('listen', [socketId, address, port, backlog, completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="setPaused">
<button class="show-code">Code</button>
Future <strong>setPaused</strong>(int socketId, bool paused) <a class="anchor-link" href="#setPaused"
              title="Permalink to ChromeSocketsTcpServer.setPaused">#</a></h4>
<div class="doc">
<p>Enables or disables a listening socket from accepting new connections. When
paused, a listening socket accepts new connections until its backlog (see
<code>listen</code> function) is full then refuses additional connection requests.
<code>onAccept</code> events are raised only when the socket is un-paused.</p>
<pre class="source">
Future setPaused(int socketId, bool paused) {
 if (_sockets_tcpServer == null) _throwNotAvailable();

 var completer = new ChromeCompleter.noArgs();
 _sockets_tcpServer.callMethod('setPaused', [socketId, paused, completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="update">
<button class="show-code">Code</button>
Future <strong>update</strong>(int socketId, <a href="../chrome.sockets/SocketProperties.html">SocketProperties</a> properties) <a class="anchor-link" href="#update"
              title="Permalink to ChromeSocketsTcpServer.update">#</a></h4>
<div class="doc">
<p>Updates the socket properties.

<span class="param">socketId</span>: The socket identifier.

<span class="param">properties</span>: The properties to update.
<code>callback</code>: Called when the properties are updated.</p>
<pre class="source">
Future update(int socketId, SocketProperties properties) {
 if (_sockets_tcpServer == null) _throwNotAvailable();

 var completer = new ChromeCompleter.noArgs();
 _sockets_tcpServer.callMethod('update', [socketId, jsify(properties), completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
