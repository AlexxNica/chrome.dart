        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>Runtime class / chrome.runtime Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="chrome.runtime" data-type="Runtime">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../chrome.runtime.html">chrome.runtime</a> &rsaquo; <a href="../chrome.runtime/Runtime.html">Runtime</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>Runtime</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<pre class="source">
class Runtime {

 Runtime._();

 dynamic get _runtime =&gt; chromeProxy.runtime;

 /**
  * This will be defined during an API method callback if there was an error.
  */
 RuntimeError get lastError {
   return js.scoped(() {
     var lastError = _runtime['lastError'];

     if (lastError == null) {
       return null;
     } else {
       return new RuntimeError(lastError.message);
     }
   });
 }

 /**
  * The ID of the extension/app.
  */
 String get id {
   return js.scoped(() {
     return _runtime.id;
   });
 }

 /// Methods

 /**
  * Retrieves the js.Proxy window object for the background page
  * running inside the current extension.
  *
  * If the background page is an event page,
  * the system will ensure it is loaded before calling the callback.
  * If there is no background page, an error is set.
  */
 Future&lt;js.Proxy&gt; getBackgroundPage() {
   ChromeCompleter completer = new ChromeCompleter.oneArg((window) {
     // XXX: This is a hack, remove or dont send the entire window object
     // as a js.Proxy to the completer.
     js.retain(window);
     return window;
   });

   js.scoped(() {
     _runtime.getBackgroundPage(completer.callback);
   });

   return completer.future;
 }

 /**
  * Returns details about the app or extension from the manifest.
  *
  * The [Map] returned is a de-serialization of the full manifest file.
  */
 Map getManifest() {
   return js.scoped(() {
     return convertJsonResponse(_runtime.getManifest());
   });
 }

 /**
  * Converts a relative path within an app/extension
  * install directory to a fully-qualified URL.
  *
  * A [path] to a resource within an app/extension
  * expressed relative to its install directory.
  */
 String getURL(String path) {
   return js.scoped(() {
     return _runtime.getURL(path);
   });
 }

 /**
  * Reloads the app or extension.
  */
 void reload() {
   js.scoped(() {
     _runtime.reload();
   });
 }

 /**
  * Requests an update check for this app/extension.
  */
 Future&lt;UpdateDetails&gt; requestUpdateCheck() {
   var completer = new ChromeCompleter.twoArgs((status, details) {
     switch (status) {
       case 'no_update':
         return UpdateDetails.NO_UPDATE;
       case 'throttled':
         return UpdateDetails.THROTTLED;
       case 'update_available':
         return new UpdateDetails.available(details.version);
       default:
         throw 'unknown status: $status';
     }
   });

   js.scoped(() {
     _runtime.requestUpdateCheck(completer.callback);
   });

   return completer.future;
 }

 /**
  * Sends a single message to onMessage event listeners within the extension
  * (or another extension/app). Similar to chrome.runtime.connect, but only
  * sends a single message with an optional response. The onMessage event is
  * fired in each extension page of the extension. Note that extensions cannot
  * send messages to content scripts using this method. To send messages to
  * content scripts, use tabs.sendMessage.
  *
  * Returns the JSON response object sent by the handler of the message.
  */
 Future&lt;dynamic&gt; sendMessage(dynamic message) {
   var completer = new ChromeCompleter.oneArg(convertJsonResponse);
   js.scoped(() {
     _runtime.sendMessage(jsifyMessage(message), completer.callback);
   });
   return completer.future;
 }

 /**
  * Returns a DirectoryEntry for the package directory.
  */
 Future&lt;DirectoryEntry&gt; getPackageDirectoryEntry() {
   ChromeCompleter&lt;DirectoryEntry&gt; completer =
       new ChromeCompleter.oneArg(Entry.createFrom);
   _runtime.getPackageDirectoryEntry(completer.callback);
   return completer.future;
 }

 /// Returns information about the current platform.
 Future&lt;PlatformInfo&gt; getPlatformInfo() {
   final completer = new ChromeCompleter.oneArg((platformInfo) =&gt;
       new PlatformInfo._(platformInfo));
   _runtime.getPlatformInfo(completer.callback);
   return completer.future;
 }

 /// Events

 final ChromeStreamController _onStartup =
     new ChromeStreamController.zeroArgs(
         () =&gt; chromeProxy.runtime.onStartup,
         () =&gt; null);

 /**
  * Fired when the browser first starts up.
  */
 Stream get onStartup =&gt; _onStartup.stream;

 final ChromeStreamController&lt;InstalledEvent&gt; _onInstalled =
     new ChromeStreamController&lt;InstalledEvent&gt;.oneArg(
         () =&gt; chromeProxy.runtime.onInstalled,
         (details) =&gt; new InstalledEvent._(
             details.reason, details['previousVersion']));

 /**
  * Fired when the extension is first installed,
  * when the extension is updated to a new version,
  * and when Chrome is updated to a new version.
  */
 Stream&lt;InstalledEvent&gt; get onInstalled =&gt; _onInstalled.stream;

 final ChromeStreamController _onSuspend =
     new ChromeStreamController.zeroArgs(
         () =&gt; chromeProxy.runtime.onSuspend,
         () =&gt; null);

 /**
  * Sent to the event page just before it is unloaded.
  *
  * This gives the extension opportunity to do some clean up.
  * Note that since the page is unloading, any asynchronous
  * operations started while handling this event are not guaranteed
  * to complete. If more activity for the event page occurs
  * before it gets unloaded the onSuspendCanceled event will be
  * sent and the page won't be unloaded.
  */
 Stream get onSuspend =&gt; _onSuspend.stream;

 final ChromeStreamController _onSuspendCanceled =
     new ChromeStreamController.zeroArgs(
         () =&gt; chromeProxy.runtime.onSuspendCanceled,
         () =&gt; null);

 /**
  * Sent after onSuspend() to indicate that the app won't be unloaded after
  * all.
  */
 Stream get onSuspendCanceled =&gt; _onSuspendCanceled.stream;

 final ChromeStreamController&lt;String&gt; _onUpdateAvailable =
     new ChromeStreamController&lt;String&gt;.oneArg(
         () =&gt; chromeProxy.runtime.onUpdateAvailable,
         (details) =&gt; details.version);

 /**
  * Fired when an update is available.
  *
  * Isn't installed immediately because the app is currently running.
  * If you do nothing, the update will be installed the next time
  * the background page gets unloaded, if you want it to be installed
  * sooner you can explicitly call chrome.runtime.reload().
  *
  * Message is the version number of the available update.
  */
 Stream&lt;String&gt; get onUpdateAvailable =&gt; _onUpdateAvailable.stream;

 ChromeStreamController&lt;MessageEvent&gt; _onMessage =
     new ChromeStreamController&lt;MessageEvent&gt;.threeArgs(
         () =&gt; chromeProxy.runtime.onMessage,
         (message, sender, sendResponse) =&gt; new MessageEvent(
               convertJsonResponse(message),
               new MessageSender(sender),
               sendResponse),
         true);

 /**
  * Fired when a message is sent from either an extension process or a content
  * script.
  */
 Stream&lt;MessageEvent&gt; get onMessage =&gt; _onMessage.stream;
}
</pre>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="id">
<button class="show-code">Code</button>
final String         <strong>id</strong> <a class="anchor-link"
            href="#id"
            title="Permalink to Runtime.id">#</a>
        </h4>
        <div class="doc">
<p>The ID of the extension/app.</p>
<pre class="source">
String get id {
 return js.scoped(() {
   return _runtime.id;
 });
}
</pre>
</div>
</div>
<div class="field"><h4 id="lastError">
<button class="show-code">Code</button>
final <a href="../chrome.runtime/RuntimeError.html">RuntimeError</a>         <strong>lastError</strong> <a class="anchor-link"
            href="#lastError"
            title="Permalink to Runtime.lastError">#</a>
        </h4>
        <div class="doc">
<p>This will be defined during an API method callback if there was an error.</p>
<pre class="source">
RuntimeError get lastError {
 return js.scoped(() {
   var lastError = _runtime['lastError'];

   if (lastError == null) {
     return null;
   } else {
     return new RuntimeError(lastError.message);
   }
 });
}
</pre>
</div>
</div>
<div class="field"><h4 id="onInstalled">
<button class="show-code">Code</button>
final Stream&lt;<a href="../chrome.runtime/InstalledEvent.html">InstalledEvent</a>&gt;         <strong>onInstalled</strong> <a class="anchor-link"
            href="#onInstalled"
            title="Permalink to Runtime.onInstalled">#</a>
        </h4>
        <div class="doc">
<p>Fired when the extension is first installed,
when the extension is updated to a new version,
and when Chrome is updated to a new version.</p>
<pre class="source">
Stream&lt;InstalledEvent&gt; get onInstalled =&gt; _onInstalled.stream;
</pre>
</div>
</div>
<div class="field"><h4 id="onMessage">
<button class="show-code">Code</button>
final Stream&lt;<a href="../chrome.runtime/MessageEvent.html">MessageEvent</a>&gt;         <strong>onMessage</strong> <a class="anchor-link"
            href="#onMessage"
            title="Permalink to Runtime.onMessage">#</a>
        </h4>
        <div class="doc">
<p>Fired when a message is sent from either an extension process or a content
script.</p>
<pre class="source">
Stream&lt;MessageEvent&gt; get onMessage =&gt; _onMessage.stream;
</pre>
</div>
</div>
<div class="field"><h4 id="onStartup">
<button class="show-code">Code</button>
final Stream         <strong>onStartup</strong> <a class="anchor-link"
            href="#onStartup"
            title="Permalink to Runtime.onStartup">#</a>
        </h4>
        <div class="doc">
<p>Fired when the browser first starts up.</p>
<pre class="source">
Stream get onStartup =&gt; _onStartup.stream;
</pre>
</div>
</div>
<div class="field"><h4 id="onSuspend">
<button class="show-code">Code</button>
final Stream         <strong>onSuspend</strong> <a class="anchor-link"
            href="#onSuspend"
            title="Permalink to Runtime.onSuspend">#</a>
        </h4>
        <div class="doc">
<p>Sent to the event page just before it is unloaded.</p>
<p>This gives the extension opportunity to do some clean up.
Note that since the page is unloading, any asynchronous
operations started while handling this event are not guaranteed
to complete. If more activity for the event page occurs
before it gets unloaded the onSuspendCanceled event will be
sent and the page won't be unloaded.</p>
<pre class="source">
Stream get onSuspend =&gt; _onSuspend.stream;
</pre>
</div>
</div>
<div class="field"><h4 id="onSuspendCanceled">
<button class="show-code">Code</button>
final Stream         <strong>onSuspendCanceled</strong> <a class="anchor-link"
            href="#onSuspendCanceled"
            title="Permalink to Runtime.onSuspendCanceled">#</a>
        </h4>
        <div class="doc">
<p>Sent after onSuspend() to indicate that the app won't be unloaded after
all.</p>
<pre class="source">
Stream get onSuspendCanceled =&gt; _onSuspendCanceled.stream;
</pre>
</div>
</div>
<div class="field"><h4 id="onUpdateAvailable">
<button class="show-code">Code</button>
final Stream&lt;String&gt;         <strong>onUpdateAvailable</strong> <a class="anchor-link"
            href="#onUpdateAvailable"
            title="Permalink to Runtime.onUpdateAvailable">#</a>
        </h4>
        <div class="doc">
<p>Fired when an update is available.</p>
<p>Isn't installed immediately because the app is currently running.
If you do nothing, the update will be installed the next time
the background page gets unloaded, if you want it to be installed
sooner you can explicitly call chrome.runtime.reload().</p>
<p>Message is the version number of the available update.</p>
<pre class="source">
Stream&lt;String&gt; get onUpdateAvailable =&gt; _onUpdateAvailable.stream;
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="getBackgroundPage">
<button class="show-code">Code</button>
Future&lt;<a href="../js/Proxy.html">Proxy</a>&gt; <strong>getBackgroundPage</strong>() <a class="anchor-link" href="#getBackgroundPage"
              title="Permalink to Runtime.getBackgroundPage">#</a></h4>
<div class="doc">
<p>Methods</p>
<p>Retrieves the js.Proxy window object for the background page
running inside the current extension.</p>
<p>If the background page is an event page,
the system will ensure it is loaded before calling the callback.
If there is no background page, an error is set.</p>
<pre class="source">
Future&lt;js.Proxy&gt; getBackgroundPage() {
 ChromeCompleter completer = new ChromeCompleter.oneArg((window) {
   // XXX: This is a hack, remove or dont send the entire window object
   // as a js.Proxy to the completer.
   js.retain(window);
   return window;
 });

 js.scoped(() {
   _runtime.getBackgroundPage(completer.callback);
 });

 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getManifest">
<button class="show-code">Code</button>
Map <strong>getManifest</strong>() <a class="anchor-link" href="#getManifest"
              title="Permalink to Runtime.getManifest">#</a></h4>
<div class="doc">
<p>Returns details about the app or extension from the manifest.</p>
<p>The <a class="crossref" href="../dart_core/Map.html">Map</a> returned is a de-serialization of the full manifest file.</p>
<pre class="source">
Map getManifest() {
 return js.scoped(() {
   return convertJsonResponse(_runtime.getManifest());
 });
}
</pre>
</div>
</div>
<div class="method"><h4 id="getPackageDirectoryEntry">
<button class="show-code">Code</button>
Future&lt;<a href="../chrome.files/DirectoryEntry.html">DirectoryEntry</a>&gt; <strong>getPackageDirectoryEntry</strong>() <a class="anchor-link" href="#getPackageDirectoryEntry"
              title="Permalink to Runtime.getPackageDirectoryEntry">#</a></h4>
<div class="doc">
<p>Returns a DirectoryEntry for the package directory.</p>
<pre class="source">
Future&lt;DirectoryEntry&gt; getPackageDirectoryEntry() {
 ChromeCompleter&lt;DirectoryEntry&gt; completer =
     new ChromeCompleter.oneArg(Entry.createFrom);
 _runtime.getPackageDirectoryEntry(completer.callback);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getPlatformInfo">
<button class="show-code">Code</button>
Future&lt;<a href="../chrome.runtime/PlatformInfo.html">PlatformInfo</a>&gt; <strong>getPlatformInfo</strong>() <a class="anchor-link" href="#getPlatformInfo"
              title="Permalink to Runtime.getPlatformInfo">#</a></h4>
<div class="doc">
<p>Returns information about the current platform.</p>
<pre class="source">
Future&lt;PlatformInfo&gt; getPlatformInfo() {
 final completer = new ChromeCompleter.oneArg((platformInfo) =&gt;
     new PlatformInfo._(platformInfo));
 _runtime.getPlatformInfo(completer.callback);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getURL">
<button class="show-code">Code</button>
String <strong>getURL</strong>(String path) <a class="anchor-link" href="#getURL"
              title="Permalink to Runtime.getURL">#</a></h4>
<div class="doc">
<p>Converts a relative path within an app/extension
install directory to a fully-qualified URL.</p>
<p>A 
<span class="param">path</span> to a resource within an app/extension
expressed relative to its install directory.</p>
<pre class="source">
String getURL(String path) {
 return js.scoped(() {
   return _runtime.getURL(path);
 });
}
</pre>
</div>
</div>
<div class="method"><h4 id="reload">
<button class="show-code">Code</button>
void <strong>reload</strong>() <a class="anchor-link" href="#reload"
              title="Permalink to Runtime.reload">#</a></h4>
<div class="doc">
<p>Reloads the app or extension.</p>
<pre class="source">
void reload() {
 js.scoped(() {
   _runtime.reload();
 });
}
</pre>
</div>
</div>
<div class="method"><h4 id="requestUpdateCheck">
<button class="show-code">Code</button>
Future&lt;<a href="../chrome.runtime/UpdateDetails.html">UpdateDetails</a>&gt; <strong>requestUpdateCheck</strong>() <a class="anchor-link" href="#requestUpdateCheck"
              title="Permalink to Runtime.requestUpdateCheck">#</a></h4>
<div class="doc">
<p>Requests an update check for this app/extension.</p>
<pre class="source">
Future&lt;UpdateDetails&gt; requestUpdateCheck() {
 var completer = new ChromeCompleter.twoArgs((status, details) {
   switch (status) {
     case 'no_update':
       return UpdateDetails.NO_UPDATE;
     case 'throttled':
       return UpdateDetails.THROTTLED;
     case 'update_available':
       return new UpdateDetails.available(details.version);
     default:
       throw 'unknown status: $status';
   }
 });

 js.scoped(() {
   _runtime.requestUpdateCheck(completer.callback);
 });

 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="sendMessage">
<button class="show-code">Code</button>
Future&lt;dynamic&gt; <strong>sendMessage</strong>(message) <a class="anchor-link" href="#sendMessage"
              title="Permalink to Runtime.sendMessage">#</a></h4>
<div class="doc">
<p>Sends a single message to onMessage event listeners within the extension
(or another extension/app). Similar to chrome.runtime.connect, but only
sends a single message with an optional response. The onMessage event is
fired in each extension page of the extension. Note that extensions cannot
send messages to content scripts using this method. To send messages to
content scripts, use tabs.sendMessage.</p>
<p>Returns the JSON response object sent by the handler of the message.</p>
<pre class="source">
Future&lt;dynamic&gt; sendMessage(dynamic message) {
 var completer = new ChromeCompleter.oneArg(convertJsonResponse);
 js.scoped(() {
   _runtime.sendMessage(jsifyMessage(message), completer.callback);
 });
 return completer.future;
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          <div>This page was generated at 2013-10-29 17:59:33.680</div>
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
