        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>Serial class / chrome.serial Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="chrome.serial" data-type="Serial">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../chrome.serial.html">chrome.serial</a> &rsaquo; <a href="../chrome.serial/Serial.html">Serial</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>Serial</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<pre class="source">
class Serial {
 Logger logger = new Logger("chrome.serial");
 OpenInfo openInfo;
 OpenOptions openOptions;

 StringBuffer _dataRead;

 final String port;
 final int speed;

 Serial(this.port, this.speed);

 /// callbacks need to check lastError
 static _safeExecute(completer, f) {
   var lastError = runtime.lastError;
   if (lastError != null) {
     completer.completeException(lastError);
     return;
   } else {
     f();
   }
 }

 static Future&lt;List&lt;String&gt;&gt; get ports {
   var completer = new Completer();

   _jsGetPorts() {
     void getPortsCallback(var result) {
       _safeExecute(completer, () {
         List ports = new List();
         for (int i = 0; i &lt; result.length; i++) {
           ports.add(result[i]);
         }

         completer.complete(ports);
       });
     };

     jsContext.getPortsCallback = new js.Callback.once(getPortsCallback);
     var chrome = chromeProxy;
     chrome.serial.getPorts(jsContext.getPortsCallback);
   };

   js.scoped(_jsGetPorts);

   return completer.future;
 }

 bool get isConnected =&gt; openInfo != null &amp;&amp; openInfo.connectionId &gt;= 0;

 Future&lt;ControlSignalOptions&gt; getControlSignalOptions() {
   var completer = new Completer();

   _jsGetControlSignalOptions() {
     void getControlSignalOptionsCallback(var result) {
       _safeExecute(completer, () {
         var controlSignalOptions =
             new ControlSignalOptions.fromMap(convertJsonResponse(result));
         completer.complete(controlSignalOptions);
       });
     };

     jsContext.getControlSignalOptionsCallback =
         new js.Callback.once(getControlSignalOptionsCallback);
     chromeProxy.serial.getControlSignals(
         openInfo.connectionId, jsContext.getControlSignalOptionsCallback);
   };

   js.scoped(_jsGetControlSignalOptions);

   return completer.future;
 }

 Future&lt;bool&gt; setControlSignalOptions(ControlSignalOptions options) {
   var completer = new Completer();

   _jsSetControlSignalOptions() {
     void setControlSignalOptionsCallback(var result) {
       _safeExecute(completer, () =&gt; completer.complete(result));
     };
     jsContext.setControlSignalOptionsCallback =
         new js.Callback.once(setControlSignalOptionsCallback);
     chromeProxy.serial.setControlSignals(
         openInfo.connectionId,
         js.map(options.toMap()),
         jsContext.setControlSignalOptionsCallback);
   };

   js.scoped(_jsSetControlSignalOptions);

   return completer.future;
 }

 Future&lt;OpenInfo&gt; open() {
   var completer = new Completer();

   _jsOpen() {
     void openCallback(var openInfo) {
       _safeExecute(completer, () {
         logger.fine("openInfo = $openInfo");

         if (openInfo != null) {
           this.openInfo = new OpenInfo(openInfo.connectionId);
         }

         completer.complete(openInfo);
       });
     };

     jsContext.openCallback = new js.Callback.once(openCallback);
     openOptions = new OpenOptions(bitrate: speed);
     var jsOpenOptions = js.map(openOptions.toMap());
     // TODO(adam): set control options before opening, control options should
     // an optioanl parameter.
     chromeProxy.serial.open(port, jsOpenOptions, jsContext.openCallback);
   };

   js.scoped(_jsOpen);

   return completer.future;
 }

 bool startListening() {
   if (isConnected) {
     _dataRead = new StringBuffer();
     _onCharRead();
     _dataRead.clear();
     return true;
   } else {
     return false;
   }
 }

 void _onCharRead() {
   if (isConnected) {
     _jsRead() {
       void readCallback(var readInfo) {
         if (readInfo != null &amp;&amp;
             readInfo.bytesRead &gt; 0 &amp;&amp;
             readInfo.data != null) {

           var bufView = new js.Proxy(jsContext.Uint8Array, readInfo.data);
           List chars = [];
           for (var i = 0; i &lt; bufView.length; i++) {
             chars.add(bufView[i]);
           }

           var str = new String.fromCharCodes(chars);
           if (str.endsWith("\n")) {
             _dataRead.write(str.substring(0, str.length - 1));

             if (onRead != null) {
               onRead(_dataRead.toString());
             }

             _dataRead.clear();
           } else {
             _dataRead.write(str);
           }
         }

         chromeProxy.serial.read(
             openInfo.connectionId, 1, jsContext.readCallback);
       };

       jsContext.readCallback = new js.Callback.many(readCallback);
       chromeProxy.serial.read(
           openInfo.connectionId, 1, jsContext.readCallback);
     };

     js.scoped(_jsRead);
   } else {
     throw new StateError("Not Connected to $port $speed");
   }

 }

 Future&lt;bool&gt; close() {
   var completer = new Completer();

   _jsClose() {
     void closeCallback(var result) {
       _safeExecute(completer, () {
         logger.fine("closeCallback = ${result}");
         openInfo = null;
         completer.complete(result);
       });
     };

     jsContext.closeCallback = new js.Callback.once(closeCallback);
     chromeProxy.serial.close(openInfo.connectionId, jsContext.closeCallback);
   };

   js.scoped(_jsClose);

   return completer.future;
 }

 SerialWriteCallback onWrite;
 SerialReadCallback onRead;

 Future&lt;WriteInfo&gt; write(String data) {
   var completer = new Completer();

   if (isConnected) {
     _jsWrite() {
       void writeCallback(var result) {
         _safeExecute(completer, () {
           logger.fine("writeInfo = ${result}");
           var writeInfo = new WriteInfo(result.bytesWritten);

           if (onWrite != null) {
             onWrite(writeInfo);
           }

           completer.complete(writeInfo);
         });
       };

       jsContext.writeCallback = new js.Callback.once(writeCallback);

       var buf = new js.Proxy(jsContext.ArrayBuffer, data.codeUnits.length);
       var bufView = (new js.Proxy(jsContext.Uint8Array, buf) as dynamic)
           ..set(js.array(data.codeUnits));

       chromeProxy.serial.write(
           openInfo.connectionId, buf, jsContext.writeCallback);
     };

     js.scoped(_jsWrite);
   } else {
     completer.completeException(
         new StateError("Serial port not connected $port $speed"));
   }

   return completer.future;
 }

 Future&lt;bool&gt; flush() {
   var completer = new Completer();

   _jsFlush() {
     void flushCallback(var result) {
       _safeExecute(completer, () =&gt; completer.complete(result));
     };

     jsContext.flushCallback = new js.Callback.once(flushCallback);
     chromeProxy.serial.flush(openInfo.connectionId, jsContext.flushCallback);
   };

   js.scoped(_jsFlush);
   return completer.future;
 }
}
</pre>
</div>
<div>
<h3>Static Properties</h3>
<div class="field"><h4 id="ports">
<button class="show-code">Code</button>
final Future&lt;List&lt;String&gt;&gt;         <strong>ports</strong> <a class="anchor-link"
            href="#ports"
            title="Permalink to Serial.ports">#</a>
        </h4>
        <div class="doc">
<pre class="source">
static Future&lt;List&lt;String&gt;&gt; get ports {
 var completer = new Completer();

 _jsGetPorts() {
   void getPortsCallback(var result) {
     _safeExecute(completer, () {
       List ports = new List();
       for (int i = 0; i &lt; result.length; i++) {
         ports.add(result[i]);
       }

       completer.complete(ports);
     });
   };

   jsContext.getPortsCallback = new js.Callback.once(getPortsCallback);
   var chrome = chromeProxy;
   chrome.serial.getPorts(jsContext.getPortsCallback);
 };

 js.scoped(_jsGetPorts);

 return completer.future;
}
</pre>
</div>
</div>
</div>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="">
<button class="show-code">Code</button>
new <strong>Serial</strong>(String port, int speed) <a class="anchor-link" href="#"
              title="Permalink to Serial.Serial">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Creates a new <a class="crossref" href="../dart_core/Object.html">Object</a> instance.</p>
<p><a class="crossref" href="../dart_core/Object.html">Object</a> instances have no meaningful state, and are only useful
through their identity. An <a class="crossref" href="../dart_core/Object.html">Object</a> instance is equal to itself
only.</p>
<div class="docs-inherited-from">docs inherited from Object </div></div>
<pre class="source">
Serial(this.port, this.speed);
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="isConnected">
<button class="show-code">Code</button>
final bool         <strong>isConnected</strong> <a class="anchor-link"
            href="#isConnected"
            title="Permalink to Serial.isConnected">#</a>
        </h4>
        <div class="doc">
<pre class="source">
bool get isConnected =&gt; openInfo != null &amp;&amp; openInfo.connectionId &gt;= 0;
</pre>
</div>
</div>
<div class="field"><h4 id="logger">
<button class="show-code">Code</button>
<a href="../logging/Logger.html">Logger</a>         <strong>logger</strong> <a class="anchor-link"
            href="#logger"
            title="Permalink to Serial.logger">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Logger logger = new Logger("chrome.serial")
</pre>
</div>
</div>
<div class="field"><h4 id="onRead">
<button class="show-code">Code</button>
<a href="../chrome.serial/SerialReadCallback.html">SerialReadCallback</a>         <strong>onRead</strong> <a class="anchor-link"
            href="#onRead"
            title="Permalink to Serial.onRead">#</a>
        </h4>
        <div class="doc">
<pre class="source">
SerialReadCallback onRead
</pre>
</div>
</div>
<div class="field"><h4 id="onWrite">
<button class="show-code">Code</button>
<a href="../chrome.serial/SerialWriteCallback.html">SerialWriteCallback</a>         <strong>onWrite</strong> <a class="anchor-link"
            href="#onWrite"
            title="Permalink to Serial.onWrite">#</a>
        </h4>
        <div class="doc">
<pre class="source">
SerialWriteCallback onWrite
</pre>
</div>
</div>
<div class="field"><h4 id="openInfo">
<button class="show-code">Code</button>
<a href="../chrome.serial/OpenInfo.html">OpenInfo</a>         <strong>openInfo</strong> <a class="anchor-link"
            href="#openInfo"
            title="Permalink to Serial.openInfo">#</a>
        </h4>
        <div class="doc">
<pre class="source">
OpenInfo openInfo
</pre>
</div>
</div>
<div class="field"><h4 id="openOptions">
<button class="show-code">Code</button>
<a href="../chrome.serial/OpenOptions.html">OpenOptions</a>         <strong>openOptions</strong> <a class="anchor-link"
            href="#openOptions"
            title="Permalink to Serial.openOptions">#</a>
        </h4>
        <div class="doc">
<pre class="source">
OpenOptions openOptions
</pre>
</div>
</div>
<div class="field"><h4 id="port">
<button class="show-code">Code</button>
final String         <strong>port</strong> <a class="anchor-link"
            href="#port"
            title="Permalink to Serial.port">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final String port
</pre>
</div>
</div>
<div class="field"><h4 id="speed">
<button class="show-code">Code</button>
final int         <strong>speed</strong> <a class="anchor-link"
            href="#speed"
            title="Permalink to Serial.speed">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final int speed
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="close">
<button class="show-code">Code</button>
Future&lt;bool&gt; <strong>close</strong>() <a class="anchor-link" href="#close"
              title="Permalink to Serial.close">#</a></h4>
<div class="doc">
<pre class="source">
Future&lt;bool&gt; close() {
 var completer = new Completer();

 _jsClose() {
   void closeCallback(var result) {
     _safeExecute(completer, () {
       logger.fine("closeCallback = ${result}");
       openInfo = null;
       completer.complete(result);
     });
   };

   jsContext.closeCallback = new js.Callback.once(closeCallback);
   chromeProxy.serial.close(openInfo.connectionId, jsContext.closeCallback);
 };

 js.scoped(_jsClose);

 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="flush">
<button class="show-code">Code</button>
Future&lt;bool&gt; <strong>flush</strong>() <a class="anchor-link" href="#flush"
              title="Permalink to Serial.flush">#</a></h4>
<div class="doc">
<pre class="source">
Future&lt;bool&gt; flush() {
 var completer = new Completer();

 _jsFlush() {
   void flushCallback(var result) {
     _safeExecute(completer, () =&gt; completer.complete(result));
   };

   jsContext.flushCallback = new js.Callback.once(flushCallback);
   chromeProxy.serial.flush(openInfo.connectionId, jsContext.flushCallback);
 };

 js.scoped(_jsFlush);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getControlSignalOptions">
<button class="show-code">Code</button>
Future&lt;<a href="../chrome.serial/ControlSignalOptions.html">ControlSignalOptions</a>&gt; <strong>getControlSignalOptions</strong>() <a class="anchor-link" href="#getControlSignalOptions"
              title="Permalink to Serial.getControlSignalOptions">#</a></h4>
<div class="doc">
<pre class="source">
Future&lt;ControlSignalOptions&gt; getControlSignalOptions() {
 var completer = new Completer();

 _jsGetControlSignalOptions() {
   void getControlSignalOptionsCallback(var result) {
     _safeExecute(completer, () {
       var controlSignalOptions =
           new ControlSignalOptions.fromMap(convertJsonResponse(result));
       completer.complete(controlSignalOptions);
     });
   };

   jsContext.getControlSignalOptionsCallback =
       new js.Callback.once(getControlSignalOptionsCallback);
   chromeProxy.serial.getControlSignals(
       openInfo.connectionId, jsContext.getControlSignalOptionsCallback);
 };

 js.scoped(_jsGetControlSignalOptions);

 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="open">
<button class="show-code">Code</button>
Future&lt;<a href="../chrome.serial/OpenInfo.html">OpenInfo</a>&gt; <strong>open</strong>() <a class="anchor-link" href="#open"
              title="Permalink to Serial.open">#</a></h4>
<div class="doc">
<pre class="source">
Future&lt;OpenInfo&gt; open() {
 var completer = new Completer();

 _jsOpen() {
   void openCallback(var openInfo) {
     _safeExecute(completer, () {
       logger.fine("openInfo = $openInfo");

       if (openInfo != null) {
         this.openInfo = new OpenInfo(openInfo.connectionId);
       }

       completer.complete(openInfo);
     });
   };

   jsContext.openCallback = new js.Callback.once(openCallback);
   openOptions = new OpenOptions(bitrate: speed);
   var jsOpenOptions = js.map(openOptions.toMap());
   // TODO(adam): set control options before opening, control options should
   // an optioanl parameter.
   chromeProxy.serial.open(port, jsOpenOptions, jsContext.openCallback);
 };

 js.scoped(_jsOpen);

 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="setControlSignalOptions">
<button class="show-code">Code</button>
Future&lt;bool&gt; <strong>setControlSignalOptions</strong>(<a href="../chrome.serial/ControlSignalOptions.html">ControlSignalOptions</a> options) <a class="anchor-link" href="#setControlSignalOptions"
              title="Permalink to Serial.setControlSignalOptions">#</a></h4>
<div class="doc">
<pre class="source">
Future&lt;bool&gt; setControlSignalOptions(ControlSignalOptions options) {
 var completer = new Completer();

 _jsSetControlSignalOptions() {
   void setControlSignalOptionsCallback(var result) {
     _safeExecute(completer, () =&gt; completer.complete(result));
   };
   jsContext.setControlSignalOptionsCallback =
       new js.Callback.once(setControlSignalOptionsCallback);
   chromeProxy.serial.setControlSignals(
       openInfo.connectionId,
       js.map(options.toMap()),
       jsContext.setControlSignalOptionsCallback);
 };

 js.scoped(_jsSetControlSignalOptions);

 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="startListening">
<button class="show-code">Code</button>
bool <strong>startListening</strong>() <a class="anchor-link" href="#startListening"
              title="Permalink to Serial.startListening">#</a></h4>
<div class="doc">
<pre class="source">
bool startListening() {
 if (isConnected) {
   _dataRead = new StringBuffer();
   _onCharRead();
   _dataRead.clear();
   return true;
 } else {
   return false;
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="write">
<button class="show-code">Code</button>
Future&lt;<a href="../chrome.serial/WriteInfo.html">WriteInfo</a>&gt; <strong>write</strong>(String data) <a class="anchor-link" href="#write"
              title="Permalink to Serial.write">#</a></h4>
<div class="doc">
<pre class="source">
Future&lt;WriteInfo&gt; write(String data) {
 var completer = new Completer();

 if (isConnected) {
   _jsWrite() {
     void writeCallback(var result) {
       _safeExecute(completer, () {
         logger.fine("writeInfo = ${result}");
         var writeInfo = new WriteInfo(result.bytesWritten);

         if (onWrite != null) {
           onWrite(writeInfo);
         }

         completer.complete(writeInfo);
       });
     };

     jsContext.writeCallback = new js.Callback.once(writeCallback);

     var buf = new js.Proxy(jsContext.ArrayBuffer, data.codeUnits.length);
     var bufView = (new js.Proxy(jsContext.Uint8Array, buf) as dynamic)
         ..set(js.array(data.codeUnits));

     chromeProxy.serial.write(
         openInfo.connectionId, buf, jsContext.writeCallback);
   };

   js.scoped(_jsWrite);
 } else {
   completer.completeException(
       new StateError("Serial port not connected $port $speed"));
 }

 return completer.future;
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          <div>This page was generated at 2013-10-03 00:19:35.066</div>
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
