        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>ContextMenus class / chrome.context_menus Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="chrome.context_menus" data-type="ContextMenus">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../chrome.context_menus.html">chrome.context_menus</a> &rsaquo; <a href="../chrome.context_menus/ContextMenus.html">ContextMenus</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>ContextMenus</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>Encapsulation of the <code>chrome.contextMenus</code> namespace.
The single instance of this class is accessed from the <a class="crossref" href="../chrome.context_menus.html#contextMenus">contextMenus</a>
getter.</p>
<pre class="source">
class ContextMenus {

 ContextMenus._();

 get _contextMenus =&gt; chromeProxy.contextMenus;

 /**
  * Creates a new context menu item. The [type] of menu item defaults to
  * [ContextMenuType.NORMAL] if not specified.
  *
  * [id] is mandatory for event pages and Cannot be the same as another ID
  * for this extension.
  *
  * [title] is required unless type is [ContextMenuType.SEPARATOR]. When the
  * context is [ContextMenuContext.SELECTION], you can use %s within the
  * string to show the selected text. For example, if this parameter's value
  * is "Translate '%s' to Pig Latin" and the user selects the word "cool",
  * the context menu item for the selection is "Translate 'cool' to Pig Latin".
  *
  * [checked] sets the initial state of a [ContextMenuType.CHECKBOX] or
  * [ContextMenuType.RADIO] item: true for selected and false for unselected.
  * Only one radio item can be selected at a time in a given group of radio
  * items.
  *
  * [contexts] defaults to [ContextMenuContext.PAGE] if not specified.
  * Specifying [ContextMenuContext.PAGE] is equivalent to the combination of
  * all other contexts except for [ContextMenuContext.LAUNCHER]. The
  * [ContextMenuContext.LAUNCHER] context is only supported by apps and is
  * used to add menu items to the context menu that appears when clicking on
  * the app icon in the launcher/taskbar/dock/etc. Different platforms might
  * put limitations on what is actually supported in a launcher context menu.
  *
  * [onClick] will be called back when the menu item is clicked. Event pages
  * cannot use this; instead, they should register a listener for
  * [chrome.contextMenus.onClicked].
  *
  * [parentId] makes the item a child of a previously added item.
  *
  * [documentUrlPatterns] lets you restrict the item to apply only to
  * documents whose URL matches one of the given patterns. (This applies to
  * frames as well.)
  *
  * [targetUrlPatterns] is similar to documentUrlPatterns, but lets you
  * filter based on the src attribute of img/audio/video tags and the href
  * of anchor tags.
  *
  * If onClick is provided, then returns a StreamSubscription object for that
  * event, otherwise returns null.
  */
 Future&lt;StreamSubscription&lt;ContextMenuClickEvent&gt;&gt; create({
     ContextMenuType type,
     String id,
     String title,
     bool checked,
     List&lt;ContextMenuContext&gt; contexts,
     void onClick(ContextMenuClickEvent event),
     String parentId,
     List&lt;String&gt; documentUrlPatterns,
     List&lt;String&gt; targetUrlPatterns,
     bool enabled}) {
   var subscription;
   Map&lt;String, dynamic&gt; createProperties = { };
   if (type != null) {
     createProperties['type'] = type.toString();
   }
   if (id != null) {
     createProperties['id'] = id;
   }
   if (title != null) {
     createProperties['title'] = title;
   }
   if (checked != null) {
     createProperties['checked'] = checked;
   }
   if (contexts != null) {
     createProperties['contexts'] = contexts.map((context) =&gt;
         context.toString());
   }
   if (onClick != null) {
     subscription = _createController(createProperties, onClick);
   }
   if (parentId != null) {
     createProperties['parentId'] = parentId;
   }
   if (documentUrlPatterns != null) {
     createProperties['documentUrlPatterns'] = documentUrlPatterns;
   }
   if (targetUrlPatterns != null) {
     createProperties['targetUrlPatterns'] = targetUrlPatterns;
   }
   if (enabled != null) {
     createProperties['enabled'] = enabled;
   }

   ChromeCompleter completer = new ChromeCompleter.noArgs();
   js.scoped(() {
     _contextMenus.create(js.map(createProperties), completer.callback);
   });
   return completer.future.then((_) =&gt; subscription);
 }

 /**
  * Updates a previously created context menu item.
  *
  * Accepts and returns the same values as [create].
  */
 Future&lt;StreamSubscription&lt;ContextMenuClickEvent&gt;&gt; update(String id, {
     ContextMenuType type,
     String title,
     bool checked,
     List&lt;ContextMenuContext&gt; contexts,
     void onClick(ContextMenuClickEvent event),
     String parentId,
     List&lt;String&gt; documentUrlPatterns,
     List&lt;String&gt; targetUrlPatterns,
     bool enabled}) {
   var subscription;
   Map&lt;String, dynamic&gt; updateProperties = { };
   if (type != null) {
     updateProperties['type'] = type.toString();
   }
   if (title != null) {
     updateProperties['title'] = title;
   }
   if (checked != null) {
     updateProperties['checked'] = checked;
   }
   if (contexts != null) {
     updateProperties['contexts'] = contexts.map((context) =&gt;
         context.toString());
   }
   if (onClick != null) {
     subscription = _createController(updateProperties, onClick);
   }
   if (parentId != null) {
     updateProperties['parentId'] = parentId;
   }
   if (documentUrlPatterns != null) {
     updateProperties['documentUrlPatterns'] = documentUrlPatterns;
   }
   if (targetUrlPatterns != null) {
     updateProperties['targetUrlPatterns'] = targetUrlPatterns;
   }
   if (enabled != null) {
     updateProperties['enabled'] = enabled;
   }

   ChromeCompleter completer = new ChromeCompleter.noArgs();
   js.scoped(() {
     _contextMenus.update(id, js.map(updateProperties), completer.callback);
   });
   return completer.future.then((_) =&gt; subscription);
 }

 StreamSubscription&lt;ContextMenuClickEvent&gt; _createController(
     Map&lt;String, dynamic&gt; properties, Function callback) {
   var controller = new StreamController.broadcast();
   properties['onclick'] =
       new js.Callback.many((dynamic clickData, [dynamic jsTab]) {
         Tab tab;
         if (jsTab != null) {
           tab = new Tab(jsTab);
         }
         controller.add(new ContextMenuClickEvent._(clickData, tab));
       });
   return controller.stream.listen(callback);
 }

 /**
  * Removes a context menu item.
  */
 Future remove(String id) {
   ChromeCompleter completer = new ChromeCompleter.noArgs();
   js.scoped(() {
     _contextMenus.remove(id, completer.callback);
   });
   return completer.future;
 }

 /**
  * Removes all context menu items added by this extension.
  */
 Future removeAll() {
   ChromeCompleter completer = new ChromeCompleter.noArgs();
   js.scoped(() {
     _contextMenus.removeAll(completer.callback);
   });
   return completer.future;
 }

 final ChromeStreamController&lt;ContextMenuClickEvent&gt; _onClicked =
     new ChromeStreamController&lt;ContextMenuClickEvent&gt;.twoArgs(
         () =&gt; chromeProxy.contextMenus.onClicked,
         (clickData, jsTab) {
           Tab tab;
           if (jsTab != null) {
             tab = new Tab(jsTab);
           }
           return new ContextMenuClickEvent._(clickData, tab);
         });

 /**
  * Fired when a context menu item is clicked.
  */
 Stream&lt;ContextMenuClickEvent&gt; get onClicked =&gt; _onClicked.stream;
}
</pre>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="onClicked">
<button class="show-code">Code</button>
final Stream&lt;<a href="../chrome.context_menus/ContextMenuClickEvent.html">ContextMenuClickEvent</a>&gt;         <strong>onClicked</strong> <a class="anchor-link"
            href="#onClicked"
            title="Permalink to ContextMenus.onClicked">#</a>
        </h4>
        <div class="doc">
<p>Fired when a context menu item is clicked.</p>
<pre class="source">
Stream&lt;ContextMenuClickEvent&gt; get onClicked =&gt; _onClicked.stream;
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="create">
<button class="show-code">Code</button>
Future&lt;StreamSubscription&lt;<a href="../chrome.context_menus/ContextMenuClickEvent.html">ContextMenuClickEvent</a>&gt;&gt; <strong>create</strong>({<a href="../chrome.context_menus/ContextMenuType.html">ContextMenuType</a> type, String id, String title, bool checked, List&lt;<a href="../chrome.context_menus/ContextMenuContext.html">ContextMenuContext</a>&gt; contexts, void onClick(<a href="../chrome.context_menus/ContextMenuClickEvent.html">ContextMenuClickEvent</a> event), String parentId, List&lt;String&gt; documentUrlPatterns, List&lt;String&gt; targetUrlPatterns, bool enabled}) <a class="anchor-link" href="#create"
              title="Permalink to ContextMenus.create">#</a></h4>
<div class="doc">
<p>Creates a new context menu item. The 
<span class="param">type</span> of menu item defaults to
<a class="crossref" href="../chrome.context_menus/ContextMenuType.html#NORMAL">ContextMenuType.NORMAL</a> if not specified.</p>
<p>
<span class="param">id</span> is mandatory for event pages and Cannot be the same as another ID
for this extension.</p>
<p>
<span class="param">title</span> is required unless type is <a class="crossref" href="../chrome.context_menus/ContextMenuType.html#SEPARATOR">ContextMenuType.SEPARATOR</a>. When the
context is <a class="crossref" href="../chrome.context_menus/ContextMenuContext.html#SELECTION">ContextMenuContext.SELECTION</a>, you can use %s within the
string to show the selected text. For example, if this parameter's value
is "Translate '%s' to Pig Latin" and the user selects the word "cool",
the context menu item for the selection is "Translate 'cool' to Pig Latin".</p>
<p>
<span class="param">checked</span> sets the initial state of a <a class="crossref" href="../chrome.context_menus/ContextMenuType.html#CHECKBOX">ContextMenuType.CHECKBOX</a> or
<a class="crossref" href="../chrome.context_menus/ContextMenuType.html#RADIO">ContextMenuType.RADIO</a> item: true for selected and false for unselected.
Only one radio item can be selected at a time in a given group of radio
items.</p>
<p>
<span class="param">contexts</span> defaults to <a class="crossref" href="../chrome.context_menus/ContextMenuContext.html#PAGE">ContextMenuContext.PAGE</a> if not specified.
Specifying <a class="crossref" href="../chrome.context_menus/ContextMenuContext.html#PAGE">ContextMenuContext.PAGE</a> is equivalent to the combination of
all other contexts except for <a class="crossref" href="../chrome.context_menus/ContextMenuContext.html#LAUNCHER">ContextMenuContext.LAUNCHER</a>. The
<a class="crossref" href="../chrome.context_menus/ContextMenuContext.html#LAUNCHER">ContextMenuContext.LAUNCHER</a> context is only supported by apps and is
used to add menu items to the context menu that appears when clicking on
the app icon in the launcher/taskbar/dock/etc. Different platforms might
put limitations on what is actually supported in a launcher context menu.</p>
<p>
<span class="param">onClick</span> will be called back when the menu item is clicked. Event pages
cannot use this; instead, they should register a listener for
<code>chrome.contextMenus.onClicked</code>.</p>
<p>
<span class="param">parentId</span> makes the item a child of a previously added item.</p>
<p>
<span class="param">documentUrlPatterns</span> lets you restrict the item to apply only to
documents whose URL matches one of the given patterns. (This applies to
frames as well.)</p>
<p>
<span class="param">targetUrlPatterns</span> is similar to documentUrlPatterns, but lets you
filter based on the src attribute of img/audio/video tags and the href
of anchor tags.</p>
<p>If onClick is provided, then returns a StreamSubscription object for that
event, otherwise returns null.</p>
<pre class="source">
Future&lt;StreamSubscription&lt;ContextMenuClickEvent&gt;&gt; create({
   ContextMenuType type,
   String id,
   String title,
   bool checked,
   List&lt;ContextMenuContext&gt; contexts,
   void onClick(ContextMenuClickEvent event),
   String parentId,
   List&lt;String&gt; documentUrlPatterns,
   List&lt;String&gt; targetUrlPatterns,
   bool enabled}) {
 var subscription;
 Map&lt;String, dynamic&gt; createProperties = { };
 if (type != null) {
   createProperties['type'] = type.toString();
 }
 if (id != null) {
   createProperties['id'] = id;
 }
 if (title != null) {
   createProperties['title'] = title;
 }
 if (checked != null) {
   createProperties['checked'] = checked;
 }
 if (contexts != null) {
   createProperties['contexts'] = contexts.map((context) =&gt;
       context.toString());
 }
 if (onClick != null) {
   subscription = _createController(createProperties, onClick);
 }
 if (parentId != null) {
   createProperties['parentId'] = parentId;
 }
 if (documentUrlPatterns != null) {
   createProperties['documentUrlPatterns'] = documentUrlPatterns;
 }
 if (targetUrlPatterns != null) {
   createProperties['targetUrlPatterns'] = targetUrlPatterns;
 }
 if (enabled != null) {
   createProperties['enabled'] = enabled;
 }

 ChromeCompleter completer = new ChromeCompleter.noArgs();
 js.scoped(() {
   _contextMenus.create(js.map(createProperties), completer.callback);
 });
 return completer.future.then((_) =&gt; subscription);
}
</pre>
</div>
</div>
<div class="method"><h4 id="remove">
<button class="show-code">Code</button>
Future <strong>remove</strong>(String id) <a class="anchor-link" href="#remove"
              title="Permalink to ContextMenus.remove">#</a></h4>
<div class="doc">
<p>Removes a context menu item.</p>
<pre class="source">
Future remove(String id) {
 ChromeCompleter completer = new ChromeCompleter.noArgs();
 js.scoped(() {
   _contextMenus.remove(id, completer.callback);
 });
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="removeAll">
<button class="show-code">Code</button>
Future <strong>removeAll</strong>() <a class="anchor-link" href="#removeAll"
              title="Permalink to ContextMenus.removeAll">#</a></h4>
<div class="doc">
<p>Removes all context menu items added by this extension.</p>
<pre class="source">
Future removeAll() {
 ChromeCompleter completer = new ChromeCompleter.noArgs();
 js.scoped(() {
   _contextMenus.removeAll(completer.callback);
 });
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="update">
<button class="show-code">Code</button>
Future&lt;StreamSubscription&lt;<a href="../chrome.context_menus/ContextMenuClickEvent.html">ContextMenuClickEvent</a>&gt;&gt; <strong>update</strong>(String id, {<a href="../chrome.context_menus/ContextMenuType.html">ContextMenuType</a> type, String title, bool checked, List&lt;<a href="../chrome.context_menus/ContextMenuContext.html">ContextMenuContext</a>&gt; contexts, void onClick(<a href="../chrome.context_menus/ContextMenuClickEvent.html">ContextMenuClickEvent</a> event), String parentId, List&lt;String&gt; documentUrlPatterns, List&lt;String&gt; targetUrlPatterns, bool enabled}) <a class="anchor-link" href="#update"
              title="Permalink to ContextMenus.update">#</a></h4>
<div class="doc">
<p>Updates a previously created context menu item.</p>
<p>Accepts and returns the same values as <a class="crossref" href="../chrome.context_menus/ContextMenus.html#create">create</a>.</p>
<pre class="source">
Future&lt;StreamSubscription&lt;ContextMenuClickEvent&gt;&gt; update(String id, {
   ContextMenuType type,
   String title,
   bool checked,
   List&lt;ContextMenuContext&gt; contexts,
   void onClick(ContextMenuClickEvent event),
   String parentId,
   List&lt;String&gt; documentUrlPatterns,
   List&lt;String&gt; targetUrlPatterns,
   bool enabled}) {
 var subscription;
 Map&lt;String, dynamic&gt; updateProperties = { };
 if (type != null) {
   updateProperties['type'] = type.toString();
 }
 if (title != null) {
   updateProperties['title'] = title;
 }
 if (checked != null) {
   updateProperties['checked'] = checked;
 }
 if (contexts != null) {
   updateProperties['contexts'] = contexts.map((context) =&gt;
       context.toString());
 }
 if (onClick != null) {
   subscription = _createController(updateProperties, onClick);
 }
 if (parentId != null) {
   updateProperties['parentId'] = parentId;
 }
 if (documentUrlPatterns != null) {
   updateProperties['documentUrlPatterns'] = documentUrlPatterns;
 }
 if (targetUrlPatterns != null) {
   updateProperties['targetUrlPatterns'] = targetUrlPatterns;
 }
 if (enabled != null) {
   updateProperties['enabled'] = enabled;
 }

 ChromeCompleter completer = new ChromeCompleter.noArgs();
 js.scoped(() {
   _contextMenus.update(id, js.map(updateProperties), completer.callback);
 });
 return completer.future.then((_) =&gt; subscription);
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          <div>This page was generated at 2013-10-22 18:21:00.319</div>
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
