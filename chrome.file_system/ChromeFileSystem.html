        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>ChromeFileSystem class / chrome.file_system Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="chrome.file_system" data-type="ChromeFileSystem">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../chrome.file_system.html">chrome.file_system</a> &rsaquo; <a href="../chrome.file_system/ChromeFileSystem.html">ChromeFileSystem</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>ChromeFileSystem</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>Use the chrome.fileSystem API to create, read, navigate, and write to a
sandboxed section of the user's local file system. With this API, packaged
apps can read and write to a user-selected location. For example, a text
editor app can use the API to read and write local documents.</p>
<pre class="source">
class ChromeFileSystem {

 ChromeFileSystem._();

 /**
  * Get the display path of an Entry object. The display path is based on the
  * full path of the file or directory on the local file system, but may be
  * made more readable for display purposes.
  */
 Future&lt;String&gt; getDisplayPath(Entry entry) {
   ChromeCompleter&lt;String&gt; completer = new ChromeCompleter.oneArg();
   chromeProxy.fileSystem.getDisplayPath(entry.proxy, completer.callback);
   return completer.future;
 }

 /**
  * Get a writable Entry from another Entry. This call will fail if the
  * application does not have the 'write' permission under 'fileSystem'. If
  * entry is a DirectoryEntry, this call will fail if the application does not
  * have the 'directory' permission under 'fileSystem'.
  *
  * Note that this will soon be deprecated.
  */
 @deprecated
 Future&lt;Entry&gt; getWritableEntry(Entry entry) {
   ChromeCompleter&lt;Entry&gt; completer = new ChromeCompleter.oneArg(Entry.createFrom);
   chromeProxy.fileSystem.getWritableEntry(entry.proxy, completer.callback);
   return completer.future;
 }

 /**
  * Gets whether this Entry is writable or not.
  *
  * Note that this will soon be deprecated.
  */
 @deprecated
 Future&lt;bool&gt; isWritableEntry(Entry entry) {
   ChromeCompleter&lt;bool&gt; completer = new ChromeCompleter.oneArg();
   chromeProxy.fileSystem.isWritableEntry(entry.proxy, completer.callback);
   return completer.future;
 }

 /**
  * Ask the user to choose a file.
  *
  * [type] is one of 'openFile', 'openWritableFile', 'saveFile'. Note that
  * 'openWritableFile' will soon be deprecated.
  *
  * This will return a dom FileEntry. js.retain() has been called on it; it is
  * the caller's responsibility to call js.release();
  */
 Future&lt;FileEntry&gt; chooseEntry({
   String type: 'openFile',
   String suggestedName,
   List&lt;ChooseEntryAccepts&gt; accepts,
   bool acceptsAllTypes: true}) {

   Map&lt;String, dynamic&gt; options = {};
   if (type != null) options['type'] = type;
   if (suggestedName != null) options['suggestedName'] = suggestedName;
   if (accepts != null) options['accepts'] = js.array(accepts);
   if (acceptsAllTypes != null) options['acceptsAllTypes'] = acceptsAllTypes;

   ChromeCompleter&lt;FileEntry&gt; completer = new ChromeCompleter.twoArgs(
       (fileEntry, fileEntries) =&gt; new FileEntry.retain(fileEntry));
   chromeProxy.fileSystem.chooseEntry(js.map(options), completer.callback);
   return completer.future;
 }

 /**
  * Ask the user to choose (open) a directory. This is sugar for the
  * chrome.fileSystem.chooseEntry call.
  *
  * This will return a dom DirectoryEntry. js.retain() has been called on it;
  * it is the caller's responsibility to call js.release();
  */
 Future&lt;DirectoryEntry&gt; chooseEntryDirectory({
   String suggestedName,
   List&lt;ChooseEntryAccepts&gt; accepts,
   bool acceptsAllTypes: true}) {

   Map&lt;String, dynamic&gt; options = {};
   options['type'] = 'openDirectory';
   if (suggestedName != null) options['suggestedName'] = suggestedName;
   if (accepts != null) options['accepts'] = js.array(accepts);
   if (acceptsAllTypes != null) options['acceptsAllTypes'] = acceptsAllTypes;

   ChromeCompleter&lt;DirectoryEntry&gt; completer = new ChromeCompleter.twoArgs(
       (fileEntry, fileEntries) =&gt; new DirectoryEntry.retain(fileEntry));
   chromeProxy.fileSystem.chooseEntry(js.map(options), completer.callback);
   return completer.future;
 }

 /**
  * Ask the user to choose one or more files. This is sugar for the
  * chrome.fileSystem.chooseEntry call.
  *
  * [type] is one of "openFile", "openWritableFile", or "saveFile"
  *
  * This will return a list of dom FileEntry objects.
  */
 Future&lt;List&lt;FileEntry&gt;&gt; chooseEntries({
   String type: 'openFile',
   String suggestedName,
   List&lt;ChooseEntryAccepts&gt; accepts,
   bool acceptsAllTypes: true}) {

   Map&lt;String, dynamic&gt; options = {};
   if (type != null) options['type'] = type;
   if (suggestedName != null) options['suggestedName'] = suggestedName;
   if (accepts != null) options['accepts'] = js.array(accepts);
   if (acceptsAllTypes != null) options['acceptsAllTypes'] = acceptsAllTypes;
   options['acceptsMultiple'] = true;

   ChromeCompleter&lt;List&lt;FileEntry&gt;&gt; completer = new ChromeCompleter.twoArgs((fileEntry, fileEntries) {
     if (fileEntries != null) {
       return listify(fileEntries).map((entry) =&gt; Entry.createFrom(entry));
     } else if (fileEntry != null) {
       return [Entry.createFrom(fileEntry)];
     } else {
       return null;
     }
   });
   chromeProxy.fileSystem.chooseEntry(js.map(options), completer.callback);
   return completer.future;
 }

 /**
  * Returns the file entry with the given id if it can be restored. This call
  * will fail otherwise. This method is new in Chrome 30.
  *
  * This will return a dom FileEntry. js.retain() has been called on it; it is
  * the caller's responsibility to call js.release();
  */
 Future&lt;FileEntry&gt; restoreEntry(String id) {
   ChromeCompleter&lt;FileEntry&gt; completer = new ChromeCompleter.oneArg(Entry.createFrom);
   chromeProxy.fileSystem.restoreEntry(id, completer.callback);
   return completer.future;
 }

 /**
  * Returns whether a file entry for the given id can be restored, i.e. whether
  * restoreEntry would succeed with this id now. This method is new in Chrome
  * 30.
  */
 Future&lt;bool&gt; isRestorable(String id) {
   ChromeCompleter&lt;bool&gt; completer = new ChromeCompleter.oneArg();
   chromeProxy.fileSystem.isRestorable(id, completer.callback);
   return completer.future;
 }

 /**
  * Returns an id that can be passed to restoreEntry to regain access to a
  * given file entry. Only the 500 most recently used entries are retained,
  * where calls to retainEntry and restoreEntry count as use. If the app has
  * the 'retainEntries' permission under 'fileSystem' (currently restricted to
  * dev channel), entries are retained indefinitely. Otherwise, entries are
  * retained only while the app is running and across restarts. This method is
  * new in Chrome 30.
  */
 String retainEntry(Entry entry) {
   return chromeProxy.fileSystem.retainEntry(entry.proxy);
 }
}
</pre>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="chooseEntries">
<button class="show-code">Code</button>
Future&lt;List&lt;<a href="../chrome.files/FileEntry.html">FileEntry</a>&gt;&gt; <strong>chooseEntries</strong>({String type: 'openFile', String suggestedName, List&lt;<a href="../chrome.file_system/ChooseEntryAccepts.html">ChooseEntryAccepts</a>&gt; accepts, bool acceptsAllTypes: true}) <a class="anchor-link" href="#chooseEntries"
              title="Permalink to ChromeFileSystem.chooseEntries">#</a></h4>
<div class="doc">
<p>Ask the user to choose one or more files. This is sugar for the
chrome.fileSystem.chooseEntry call.</p>
<p>
<span class="param">type</span> is one of "openFile", "openWritableFile", or "saveFile"</p>
<p>This will return a list of dom FileEntry objects.</p>
<pre class="source">
Future&lt;List&lt;FileEntry&gt;&gt; chooseEntries({
 String type: 'openFile',
 String suggestedName,
 List&lt;ChooseEntryAccepts&gt; accepts,
 bool acceptsAllTypes: true}) {

 Map&lt;String, dynamic&gt; options = {};
 if (type != null) options['type'] = type;
 if (suggestedName != null) options['suggestedName'] = suggestedName;
 if (accepts != null) options['accepts'] = js.array(accepts);
 if (acceptsAllTypes != null) options['acceptsAllTypes'] = acceptsAllTypes;
 options['acceptsMultiple'] = true;

 ChromeCompleter&lt;List&lt;FileEntry&gt;&gt; completer = new ChromeCompleter.twoArgs((fileEntry, fileEntries) {
   if (fileEntries != null) {
     return listify(fileEntries).map((entry) =&gt; Entry.createFrom(entry));
   } else if (fileEntry != null) {
     return [Entry.createFrom(fileEntry)];
   } else {
     return null;
   }
 });
 chromeProxy.fileSystem.chooseEntry(js.map(options), completer.callback);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="chooseEntry">
<button class="show-code">Code</button>
Future&lt;<a href="../chrome.files/FileEntry.html">FileEntry</a>&gt; <strong>chooseEntry</strong>({String type: 'openFile', String suggestedName, List&lt;<a href="../chrome.file_system/ChooseEntryAccepts.html">ChooseEntryAccepts</a>&gt; accepts, bool acceptsAllTypes: true}) <a class="anchor-link" href="#chooseEntry"
              title="Permalink to ChromeFileSystem.chooseEntry">#</a></h4>
<div class="doc">
<p>Ask the user to choose a file.</p>
<p>
<span class="param">type</span> is one of 'openFile', 'openWritableFile', 'saveFile'. Note that
'openWritableFile' will soon be deprecated.</p>
<p>This will return a dom FileEntry. js.retain() has been called on it; it is
the caller's responsibility to call js.release();</p>
<pre class="source">
Future&lt;FileEntry&gt; chooseEntry({
 String type: 'openFile',
 String suggestedName,
 List&lt;ChooseEntryAccepts&gt; accepts,
 bool acceptsAllTypes: true}) {

 Map&lt;String, dynamic&gt; options = {};
 if (type != null) options['type'] = type;
 if (suggestedName != null) options['suggestedName'] = suggestedName;
 if (accepts != null) options['accepts'] = js.array(accepts);
 if (acceptsAllTypes != null) options['acceptsAllTypes'] = acceptsAllTypes;

 ChromeCompleter&lt;FileEntry&gt; completer = new ChromeCompleter.twoArgs(
     (fileEntry, fileEntries) =&gt; new FileEntry.retain(fileEntry));
 chromeProxy.fileSystem.chooseEntry(js.map(options), completer.callback);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="chooseEntryDirectory">
<button class="show-code">Code</button>
Future&lt;<a href="../chrome.files/DirectoryEntry.html">DirectoryEntry</a>&gt; <strong>chooseEntryDirectory</strong>({String suggestedName, List&lt;<a href="../chrome.file_system/ChooseEntryAccepts.html">ChooseEntryAccepts</a>&gt; accepts, bool acceptsAllTypes: true}) <a class="anchor-link" href="#chooseEntryDirectory"
              title="Permalink to ChromeFileSystem.chooseEntryDirectory">#</a></h4>
<div class="doc">
<p>Ask the user to choose (open) a directory. This is sugar for the
chrome.fileSystem.chooseEntry call.</p>
<p>This will return a dom DirectoryEntry. js.retain() has been called on it;
it is the caller's responsibility to call js.release();</p>
<pre class="source">
Future&lt;DirectoryEntry&gt; chooseEntryDirectory({
 String suggestedName,
 List&lt;ChooseEntryAccepts&gt; accepts,
 bool acceptsAllTypes: true}) {

 Map&lt;String, dynamic&gt; options = {};
 options['type'] = 'openDirectory';
 if (suggestedName != null) options['suggestedName'] = suggestedName;
 if (accepts != null) options['accepts'] = js.array(accepts);
 if (acceptsAllTypes != null) options['acceptsAllTypes'] = acceptsAllTypes;

 ChromeCompleter&lt;DirectoryEntry&gt; completer = new ChromeCompleter.twoArgs(
     (fileEntry, fileEntries) =&gt; new DirectoryEntry.retain(fileEntry));
 chromeProxy.fileSystem.chooseEntry(js.map(options), completer.callback);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getDisplayPath">
<button class="show-code">Code</button>
Future&lt;String&gt; <strong>getDisplayPath</strong>(<a href="../chrome.files/Entry.html">Entry</a> entry) <a class="anchor-link" href="#getDisplayPath"
              title="Permalink to ChromeFileSystem.getDisplayPath">#</a></h4>
<div class="doc">
<p>Get the display path of an Entry object. The display path is based on the
full path of the file or directory on the local file system, but may be
made more readable for display purposes.</p>
<pre class="source">
Future&lt;String&gt; getDisplayPath(Entry entry) {
 ChromeCompleter&lt;String&gt; completer = new ChromeCompleter.oneArg();
 chromeProxy.fileSystem.getDisplayPath(entry.proxy, completer.callback);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getWritableEntry">
<button class="show-code">Code</button>
Future&lt;<a href="../chrome.files/Entry.html">Entry</a>&gt; <strong>getWritableEntry</strong>(<a href="../chrome.files/Entry.html">Entry</a> entry) <a class="anchor-link" href="#getWritableEntry"
              title="Permalink to ChromeFileSystem.getWritableEntry">#</a></h4>
<div class="doc">
<p>Get a writable Entry from another Entry. This call will fail if the
application does not have the 'write' permission under 'fileSystem'. If
entry is a DirectoryEntry, this call will fail if the application does not
have the 'directory' permission under 'fileSystem'.</p>
<p>Note that this will soon be deprecated.</p>
<pre class="source">
@deprecated
Future&lt;Entry&gt; getWritableEntry(Entry entry) {
 ChromeCompleter&lt;Entry&gt; completer = new ChromeCompleter.oneArg(Entry.createFrom);
 chromeProxy.fileSystem.getWritableEntry(entry.proxy, completer.callback);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="isRestorable">
<button class="show-code">Code</button>
Future&lt;bool&gt; <strong>isRestorable</strong>(String id) <a class="anchor-link" href="#isRestorable"
              title="Permalink to ChromeFileSystem.isRestorable">#</a></h4>
<div class="doc">
<p>Returns whether a file entry for the given id can be restored, i.e. whether
restoreEntry would succeed with this id now. This method is new in Chrome
30.</p>
<pre class="source">
Future&lt;bool&gt; isRestorable(String id) {
 ChromeCompleter&lt;bool&gt; completer = new ChromeCompleter.oneArg();
 chromeProxy.fileSystem.isRestorable(id, completer.callback);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="isWritableEntry">
<button class="show-code">Code</button>
Future&lt;bool&gt; <strong>isWritableEntry</strong>(<a href="../chrome.files/Entry.html">Entry</a> entry) <a class="anchor-link" href="#isWritableEntry"
              title="Permalink to ChromeFileSystem.isWritableEntry">#</a></h4>
<div class="doc">
<p>Gets whether this Entry is writable or not.</p>
<p>Note that this will soon be deprecated.</p>
<pre class="source">
@deprecated
Future&lt;bool&gt; isWritableEntry(Entry entry) {
 ChromeCompleter&lt;bool&gt; completer = new ChromeCompleter.oneArg();
 chromeProxy.fileSystem.isWritableEntry(entry.proxy, completer.callback);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="restoreEntry">
<button class="show-code">Code</button>
Future&lt;<a href="../chrome.files/FileEntry.html">FileEntry</a>&gt; <strong>restoreEntry</strong>(String id) <a class="anchor-link" href="#restoreEntry"
              title="Permalink to ChromeFileSystem.restoreEntry">#</a></h4>
<div class="doc">
<p>Returns the file entry with the given id if it can be restored. This call
will fail otherwise. This method is new in Chrome 30.</p>
<p>This will return a dom FileEntry. js.retain() has been called on it; it is
the caller's responsibility to call js.release();</p>
<pre class="source">
Future&lt;FileEntry&gt; restoreEntry(String id) {
 ChromeCompleter&lt;FileEntry&gt; completer = new ChromeCompleter.oneArg(Entry.createFrom);
 chromeProxy.fileSystem.restoreEntry(id, completer.callback);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="retainEntry">
<button class="show-code">Code</button>
String <strong>retainEntry</strong>(<a href="../chrome.files/Entry.html">Entry</a> entry) <a class="anchor-link" href="#retainEntry"
              title="Permalink to ChromeFileSystem.retainEntry">#</a></h4>
<div class="doc">
<p>Returns an id that can be passed to restoreEntry to regain access to a
given file entry. Only the 500 most recently used entries are retained,
where calls to retainEntry and restoreEntry count as use. If the app has
the 'retainEntries' permission under 'fileSystem' (currently restricted to
dev channel), entries are retained indefinitely. Otherwise, entries are
retained only while the app is running and across restarts. This method is
new in Chrome 30.</p>
<pre class="source">
String retainEntry(Entry entry) {
 return chromeProxy.fileSystem.retainEntry(entry.proxy);
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          <div>This page was generated at 2013-09-09 23:42:18.122</div>
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
