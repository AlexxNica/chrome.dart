{"name":"ChromeRuntime","qualifiedName":"chrome/chrome_ext.ChromeRuntime","comment":"","isAbstract":false,"superclass":"chrome/chrome_ext.ChromeApi","implements":[],"subclass":[],"variables":{"_onStartup":{"name":"_onStartup","qualifiedName":"chrome/chrome_app.ChromeRuntime._onStartup","comment":"","final":false,"static":false,"constant":false,"type":[{"outer":"chrome/chrome-src-common.ChromeStreamController","inner":[]}],"annotations":[]},"_onInstalled":{"name":"_onInstalled","qualifiedName":"chrome/chrome_app.ChromeRuntime._onInstalled","comment":"","final":false,"static":false,"constant":false,"type":[{"outer":"chrome/chrome-src-common.ChromeStreamController","inner":[{"outer":"dart-core.Map","inner":[]}]}],"annotations":[]},"_onSuspend":{"name":"_onSuspend","qualifiedName":"chrome/chrome_app.ChromeRuntime._onSuspend","comment":"","final":false,"static":false,"constant":false,"type":[{"outer":"chrome/chrome-src-common.ChromeStreamController","inner":[]}],"annotations":[]},"_onSuspendCanceled":{"name":"_onSuspendCanceled","qualifiedName":"chrome/chrome_app.ChromeRuntime._onSuspendCanceled","comment":"","final":false,"static":false,"constant":false,"type":[{"outer":"chrome/chrome-src-common.ChromeStreamController","inner":[]}],"annotations":[]},"_onUpdateAvailable":{"name":"_onUpdateAvailable","qualifiedName":"chrome/chrome_app.ChromeRuntime._onUpdateAvailable","comment":"","final":false,"static":false,"constant":false,"type":[{"outer":"chrome/chrome-src-common.ChromeStreamController","inner":[{"outer":"dart-core.Map","inner":[{"outer":"dart-core.String","inner":[]},{"outer":"dynamic","inner":[]}]}]}],"annotations":[]},"_onBrowserUpdateAvailable":{"name":"_onBrowserUpdateAvailable","qualifiedName":"chrome/chrome_app.ChromeRuntime._onBrowserUpdateAvailable","comment":"","final":false,"static":false,"constant":false,"type":[{"outer":"chrome/chrome-src-common.ChromeStreamController","inner":[]}],"annotations":[]},"_onConnect":{"name":"_onConnect","qualifiedName":"chrome/chrome_app.ChromeRuntime._onConnect","comment":"","final":false,"static":false,"constant":false,"type":[{"outer":"chrome/chrome-src-common.ChromeStreamController","inner":[{"outer":"chrome/chrome_app.Port","inner":[]}]}],"annotations":[]},"_onConnectExternal":{"name":"_onConnectExternal","qualifiedName":"chrome/chrome_app.ChromeRuntime._onConnectExternal","comment":"","final":false,"static":false,"constant":false,"type":[{"outer":"chrome/chrome-src-common.ChromeStreamController","inner":[{"outer":"chrome/chrome_app.Port","inner":[]}]}],"annotations":[]},"_onMessage":{"name":"_onMessage","qualifiedName":"chrome/chrome_app.ChromeRuntime._onMessage","comment":"","final":false,"static":false,"constant":false,"type":[{"outer":"chrome/chrome-src-common.ChromeStreamController","inner":[{"outer":"chrome/chrome_app.OnMessageEvent","inner":[]}]}],"annotations":[]},"_onMessageExternal":{"name":"_onMessageExternal","qualifiedName":"chrome/chrome_app.ChromeRuntime._onMessageExternal","comment":"","final":false,"static":false,"constant":false,"type":[{"outer":"chrome/chrome-src-common.ChromeStreamController","inner":[{"outer":"chrome/chrome_app.OnMessageExternalEvent","inner":[]}]}],"annotations":[]},"_onRestartRequired":{"name":"_onRestartRequired","qualifiedName":"chrome/chrome_app.ChromeRuntime._onRestartRequired","comment":"","final":false,"static":false,"constant":false,"type":[{"outer":"chrome/chrome-src-common.ChromeStreamController","inner":[{"outer":"dart-core.String","inner":[]}]}],"annotations":[]}},"inheritedVariables":{},"methods":{"setters":{},"getters":{"_runtime":{"name":"_runtime","qualifiedName":"chrome/chrome_ext.ChromeRuntime._runtime","comment":"","commentFrom":"chrome_app.ChromeRuntime._runtime","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-js.JsObject","inner":[]}],"parameters":{},"annotations":[]},"onStartup":{"name":"onStartup","qualifiedName":"chrome/chrome_ext.ChromeRuntime.onStartup","comment":"<p>Fired when a profile that has this extension installed first starts up.\nThis event is not fired when an incognito profile is started, even if this\nextension is operating in 'split' incognito mode.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Stream","inner":[]}],"parameters":{},"annotations":[]},"onInstalled":{"name":"onInstalled","qualifiedName":"chrome/chrome_ext.ChromeRuntime.onInstalled","comment":"<p>Fired when the extension is first installed, when the extension is updated\nto a new version, and when Chrome is updated to a new version.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Stream","inner":[{"outer":"dart-core.Map","inner":[]}]}],"parameters":{},"annotations":[]},"onSuspend":{"name":"onSuspend","qualifiedName":"chrome/chrome_ext.ChromeRuntime.onSuspend","comment":"<p>Sent to the event page just before it is unloaded. This gives the extension\nopportunity to do some clean up. Note that since the page is unloading, any\nasynchronous operations started while handling this event are not\nguaranteed to complete. If more activity for the event page occurs before\nit gets unloaded the onSuspendCanceled event will be sent and the page\nwon't be unloaded.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Stream","inner":[]}],"parameters":{},"annotations":[]},"onSuspendCanceled":{"name":"onSuspendCanceled","qualifiedName":"chrome/chrome_ext.ChromeRuntime.onSuspendCanceled","comment":"<p>Sent after onSuspend to indicate that the app won't be unloaded after all.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Stream","inner":[]}],"parameters":{},"annotations":[]},"onUpdateAvailable":{"name":"onUpdateAvailable","qualifiedName":"chrome/chrome_ext.ChromeRuntime.onUpdateAvailable","comment":"<p>Fired when an update is available, but isn't installed immediately because\nthe app is currently running. If you do nothing, the update will be\ninstalled the next time the background page gets unloaded, if you want it\nto be installed sooner you can explicitly call chrome.runtime.reload().</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Stream","inner":[{"outer":"dart-core.Map","inner":[{"outer":"dart-core.String","inner":[]},{"outer":"dynamic","inner":[]}]}]}],"parameters":{},"annotations":[]},"onBrowserUpdateAvailable":{"name":"onBrowserUpdateAvailable","qualifiedName":"chrome/chrome_ext.ChromeRuntime.onBrowserUpdateAvailable","comment":"<p>Fired when a Chrome update is available, but isn't installed immediately\nbecause a browser restart is required.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Stream","inner":[]}],"parameters":{},"annotations":[]},"onConnect":{"name":"onConnect","qualifiedName":"chrome/chrome_ext.ChromeRuntime.onConnect","comment":"<p>Fired when a connection is made from either an extension process or a\ncontent script.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Stream","inner":[{"outer":"chrome/chrome_ext.Port","inner":[]}]}],"parameters":{},"annotations":[]},"onConnectExternal":{"name":"onConnectExternal","qualifiedName":"chrome/chrome_ext.ChromeRuntime.onConnectExternal","comment":"<p>Fired when a connection is made from another extension.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Stream","inner":[{"outer":"chrome/chrome_ext.Port","inner":[]}]}],"parameters":{},"annotations":[]},"onMessage":{"name":"onMessage","qualifiedName":"chrome/chrome_ext.ChromeRuntime.onMessage","comment":"<p>Fired when a message is sent from either an extension process or a content\nscript.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Stream","inner":[{"outer":"chrome/chrome_ext.OnMessageEvent","inner":[]}]}],"parameters":{},"annotations":[]},"onMessageExternal":{"name":"onMessageExternal","qualifiedName":"chrome/chrome_ext.ChromeRuntime.onMessageExternal","comment":"<p>Fired when a message is sent from another extension/app. Cannot be used in\na content script.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Stream","inner":[{"outer":"chrome/chrome_ext.OnMessageExternalEvent","inner":[]}]}],"parameters":{},"annotations":[]},"onRestartRequired":{"name":"onRestartRequired","qualifiedName":"chrome/chrome_ext.ChromeRuntime.onRestartRequired","comment":"<p>Fired when an app or the device that it runs on needs to be restarted. The\napp should close all its windows at its earliest convenient time to let the\nrestart to happen. If the app does nothing, a restart will be enforced\nafter a 24-hour grace period has passed. Currently, this event is only\nfired for Chrome OS kiosk apps.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Stream","inner":[{"outer":"dart-core.String","inner":[]}]}],"parameters":{},"annotations":[]},"available":{"name":"available","qualifiedName":"chrome/chrome_ext.ChromeRuntime.available","comment":"<p>Returns true if the API is available. The common causes of an API not being\navilable are:</p><ul><li>a permission is missing in the application's manifest.json file</li><li>the API is defined on a newer version of Chrome then the current runtime</li></ul>","commentFrom":"chrome_app.ChromeApi.available","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"lastError":{"name":"lastError","qualifiedName":"chrome/chrome_ext.ChromeRuntime.lastError","comment":"<p>This will be defined during an API method callback if there was an error</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"chrome/chrome_ext.LastErrorRuntime","inner":[]}],"parameters":{},"annotations":[]},"id":{"name":"id","qualifiedName":"chrome/chrome_ext.ChromeRuntime.id","comment":"<p>The ID of the extension/app.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{"_":{"name":"_","qualifiedName":"chrome/chrome_ext.ChromeRuntime.ChromeRuntime-_","comment":"","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{},"annotations":[]}},"operators":{},"methods":{"getBackgroundPage":{"name":"getBackgroundPage","qualifiedName":"chrome/chrome_ext.ChromeRuntime.getBackgroundPage","comment":"<p>Retrieves the JavaScript 'window' object for the background page running\ninside the current extension/app. If the background page is an event page,\nthe system will ensure it is loaded before calling the callback. If there\nis no background page, an error is set.</p>\n<p>Returns:\nThe JavaScript 'window' object for the background page.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"chrome/chrome_ext.Window","inner":[]}]}],"parameters":{},"annotations":[]},"getManifest":{"name":"getManifest","qualifiedName":"chrome/chrome_ext.ChromeRuntime.getManifest","comment":"<p>Returns details about the app or extension from the manifest. The object\nreturned is a serialization of the full <a href=\"manifest.html\">manifest file</a>.</p>\n<p>Returns:\nThe manifest details.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Map","inner":[{"outer":"dart-core.String","inner":[]},{"outer":"dynamic","inner":[]}]}],"parameters":{},"annotations":[]},"getURL":{"name":"getURL","qualifiedName":"chrome/chrome_ext.ChromeRuntime.getURL","comment":"<p>Converts a relative path within an app/extension install directory to a\nfully-qualified URL.</p>\n<p><a>chrome/chrome_ext.ChromeRuntime.getURL.path</a> A path to a resource within an app/extension expressed relative to\nits install directory.</p>\n<p>Returns:\nThe fully-qualified URL to the resource.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"path":{"name":"path","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"setUninstallUrl":{"name":"setUninstallUrl","qualifiedName":"chrome/chrome_ext.ChromeRuntime.setUninstallUrl","comment":"<p>Sets the URL to be visited upon uninstallation. This may be used to clean\nup server-side data, do analytics, and implement surveys. Maximum 255\ncharacters.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"url":{"name":"url","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"reload":{"name":"reload","qualifiedName":"chrome/chrome_ext.ChromeRuntime.reload","comment":"<p>Reloads the app or extension.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{},"annotations":[]},"requestUpdateCheck":{"name":"requestUpdateCheck","qualifiedName":"chrome/chrome_ext.ChromeRuntime.requestUpdateCheck","comment":"<p>Requests an update check for this app/extension.</p>\n<p>Returns:\nstatus Result of the update check.\nenum of <code>throttled</code>, <code>no_update</code>, <code>update_available</code>\ndetails If an update is available, this contains more information about\nthe available update.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"chrome/chrome_ext.RequestUpdateCheckResult","inner":[]}]}],"parameters":{},"annotations":[]},"restart":{"name":"restart","qualifiedName":"chrome/chrome_ext.ChromeRuntime.restart","comment":"<p>Restart the ChromeOS device when the app runs in kiosk mode. Otherwise,\nit's no-op.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{},"annotations":[]},"connect":{"name":"connect","qualifiedName":"chrome/chrome_ext.ChromeRuntime.connect","comment":"<p>Attempts to connect to other listeners within the extension/app (such as\nthe background page), or other extensions/apps. This is useful for content\nscripts connecting to their extension processes. Note that this does not\nconnect to any listeners in a content script. Extensions may connect to\ncontent scripts embedded in tabs via tabs.connect.</p>\n<p><a>chrome/chrome_ext.ChromeRuntime.connect.extensionId</a> The ID of the extension/app you want to connect to. If\nomitted, default is your own extension.</p>\n<p>Returns:\nPort through which messages can be sent and received. The port's\n[][runtime.Port onDisconnect] event is fired if the extension/app does not\nexist.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"chrome/chrome_ext.Port","inner":[]}],"parameters":{"extensionId":{"name":"extensionId","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]},"connectInfo":{"name":"connectInfo","optional":true,"named":false,"default":false,"type":[{"outer":"chrome/chrome_ext.RuntimeConnectParams","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"connectNative":{"name":"connectNative","qualifiedName":"chrome/chrome_ext.ChromeRuntime.connectNative","comment":"<p>Connects to a native application in the host machine.</p>\n<p><a>chrome/chrome_ext.ChromeRuntime.connectNative.application</a> The name of the registered application to connect to.</p>\n<p>Returns:\nPort through which messages can be sent and received with the application</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"chrome/chrome_ext.Port","inner":[]}],"parameters":{"application":{"name":"application","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"sendMessage":{"name":"sendMessage","qualifiedName":"chrome/chrome_ext.ChromeRuntime.sendMessage","comment":"<p>Sends a single message to onMessage event listeners within the extension\n(or another extension/app). Similar to chrome.runtime.connect, but only\nsends a single message with an optional response. The runtime.onMessage\nevent is fired in each extension page of the extension. Note that\nextensions cannot send messages to content scripts using this method. To\nsend messages to content scripts, use tabs.sendMessage.</p>\n<p><a>chrome/chrome_ext.ChromeRuntime.sendMessage.extensionId</a> The extension ID of the extension you want to connect to. If\nomitted, default is your own extension.</p>\n<p>Returns:\nThe JSON response object sent by the handler of the message. If an error\noccurs while connecting to the extension, the callback will be called with\nno arguments and runtime.lastError will be set to the error message.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dynamic","inner":[]}]}],"parameters":{"message":{"name":"message","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"extensionId":{"name":"extensionId","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]},"options":{"name":"options","optional":true,"named":false,"default":false,"type":[{"outer":"chrome/chrome_ext.RuntimeSendMessageParams","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"sendNativeMessage":{"name":"sendNativeMessage","qualifiedName":"chrome/chrome_ext.ChromeRuntime.sendNativeMessage","comment":"<p>Send a single message to a native application.</p>\n<p><a>chrome/chrome_ext.ChromeRuntime.sendNativeMessage.application</a> The name of the native messaging host.</p>\n<p><a>chrome/chrome_ext.ChromeRuntime.sendNativeMessage.message</a> The message that will be passed to the native messaging host.</p>\n<p>Returns:\nThe response message send by the native messaging host. If an error occurs\nwhile connecting to the native messaging host, the callback will be called\nwith no arguments and runtime.lastError will be set to the error message.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dynamic","inner":[]}]}],"parameters":{"application":{"name":"application","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]},"message":{"name":"message","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Map","inner":[{"outer":"dart-core.String","inner":[]},{"outer":"dynamic","inner":[]}]}],"value":"null","annotations":[]}},"annotations":[]},"getPlatformInfo":{"name":"getPlatformInfo","qualifiedName":"chrome/chrome_ext.ChromeRuntime.getPlatformInfo","comment":"<p>Returns information about the current platform.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-core.Map","inner":[]}]}],"parameters":{},"annotations":[]},"getPackageDirectoryEntry":{"name":"getPackageDirectoryEntry","qualifiedName":"chrome/chrome_ext.ChromeRuntime.getPackageDirectoryEntry","comment":"<p>Returns a DirectoryEntry for the package directory.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-dom-html.DirectoryEntry","inner":[]}]}],"parameters":{},"annotations":[]},"_throwNotAvailable":{"name":"_throwNotAvailable","qualifiedName":"chrome/chrome_ext.ChromeRuntime._throwNotAvailable","comment":"","commentFrom":"chrome_app.ChromeRuntime._throwNotAvailable","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{},"annotations":[]}}},"inheritedMethods":{"setters":{},"getters":{"hashCode":{"name":"hashCode","qualifiedName":"chrome/chrome_ext.ChromeRuntime.hashCode","comment":"<p>Get a hash code for this object.</p>\n<p>All objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator <code>==</code>. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.</p>\n<p>If a subclass overrides <a>chrome/chrome_ext.ChromeRuntime.hashCode</a> it should override the\nequality operator as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.hashCode","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"runtimeType":{"name":"runtimeType","qualifiedName":"chrome/chrome_ext.ChromeRuntime.runtimeType","comment":"<p>A representation of the runtime type of the object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.runtimeType","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Type","inner":[]}],"parameters":{},"annotations":[]},"available":{"name":"available","qualifiedName":"chrome/chrome_ext.ChromeRuntime.available","comment":"<p>Returns true if the API is available. The common causes of an API not being\navilable are:</p><ul><li>a permission is missing in the application's manifest.json file</li><li>the API is defined on a newer version of Chrome then the current runtime</li></ul>","commentFrom":"","inheritedFrom":"chrome_ext.ChromeApi.available","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{"==":{"name":"==","qualifiedName":"chrome/chrome_ext.ChromeRuntime.==","comment":"<p>The equality operator.</p>\n<p>The default behavior for all <a>dart-core.Object</a>s is to return true if and\nonly if <code>this</code> and <a>chrome/chrome_ext.ChromeRuntime.==.other</a> are the same object.</p>\n<p>Override this method to specify a different equality relation on\na class. The overriding method must still be an equivalence relation.\nThat is, it must be:</p><ul><li>\n<p>Total: It must return a boolean for all arguments. It should never throw\n   or return <code>null</code>.</p></li><li>\n<p>Reflexive: For all objects <code>o</code>, <code>o == o</code> must be true.</p></li><li>\n<p>Symmetric: For all objects <code>o1</code> and <code>o2</code>, <code>o1 == o2</code> and <code>o2 == o1</code> must\n   either both be true, or both be false.</p></li><li>\n<p>Transitive: For all objects <code>o1</code>, <code>o2</code>, and <code>o3</code>, if <code>o1 == o2</code> and\n   <code>o2 == o3</code> are true, then <code>o1 == o3</code> must be true.</p></li></ul>\n<p>The method should also be consistent over time, so equality of two objects\nshould not change over time, or at least only change if one of the objects\nwas modified.</p>\n<p>If a subclass overrides the equality operator it should override\nthe <a>chrome/chrome_ext.ChromeRuntime.hashCode</a> method as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.==","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]}},"methods":{"toString":{"name":"toString","qualifiedName":"chrome/chrome_ext.ChromeRuntime.toString","comment":"<p>Returns a string representation of this object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.toString","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"noSuchMethod":{"name":"noSuchMethod","qualifiedName":"chrome/chrome_ext.ChromeRuntime.noSuchMethod","comment":"<p><a>chrome/chrome_ext.ChromeRuntime.noSuchMethod</a> is invoked when users invoke a non-existent method\non an object. The name of the method and the arguments of the\ninvocation are passed to <a>chrome/chrome_ext.ChromeRuntime.noSuchMethod</a> in an <a>dart-core.Invocation</a>.\nIf <a>chrome/chrome_ext.ChromeRuntime.noSuchMethod</a> returns a value, that value becomes the result of\nthe original invocation.</p>\n<p>The default behavior of <a>chrome/chrome_ext.ChromeRuntime.noSuchMethod</a> is to throw a\n<a>dart-core.NoSuchMethodError</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.noSuchMethod","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"invocation":{"name":"invocation","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Invocation","inner":[]}],"value":"null","annotations":[]}},"annotations":[]}}},"annotations":[],"generics":{}}